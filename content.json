{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"FastApi","text":"FastAPI framework, high performance, easy to learn, fast to code, ready for production Documentation: https://fastapi.tiangolo.com 如果应对一个非常简单的需求，比如编写一个接口，总不能直接Django，但也不能写的很糙。如果用Flask，虽然可以用很短的代码写出一个能用的项目，但是需要很多地方需要处理。 如果使用FastApi就会简单很多： 1234567891011121314from fastapi import FastAPIfrom pydantic import BaseModelapp = FastAPI()class People(BaseModel): name:str age:int address:str salary:float@app.post('/insert')def insert(people:People): age_after_10_years = people.age + 10 msg = \"人名：{people.name},十年后的年龄为：{age_after_10_years}' return {'success:'True,'msg':msg} 启动服务后，如果传入错误的值，返回值将会非常友好的告诉你哪里出错了。对类型的检查全部由FastAPI自己完成，非常pythonic。使用fastAPI 需要使用uvicorn来运行FastAPI 12pip install uvicornuvicorn main:app --reload main: 代码文件名 main.pyapp: 初始化FastAPI的对象名–reload 代码修改后立即生效，不需要重启 GET 方法定义1234@app.get('/quert/{uid}')def query(uid): msg = '您查询的uid为：{uid}' return {'success':True,'msg':msg} 直接请求该地址：http://127.0.0.1:8000/query/789如果限定uid的类型，只需要在函数定义时候指定类型 1def quert(uid:int): 除了这些之外，FastAPI还能帮我们快速的生成接口文档。http://127.0.0.1:8000/docs","link":"/2020/01/20/FastApi/"},{"title":"及时行乐","text":"及时行乐（Enjoy Pleasure in Good Time.） 人生苦短,何不及时行乐释义：抓紧时机，不失时机，寻欢作乐。 出处:《新刊大宋宣和遗事》：“人生如白驹过隙，倘不及时行乐，则老大徒伤悲也。”例句：短歌行（曹操）对酒当歌，人生几何？ 譬如朝露，去日苦多。 慨当以慷，忧思难忘。 何以解忧？唯有杜康。 So, there you have it… enjoy!","link":"/2018/08/03/about/"},{"title":"友善之臂移植香蕉派的树莓派系统，并进行精简","text":"使用BPI-M2P-H3 的Raspbian ROM，用etcher烧录到tf卡中，安装xrdp进行远程桌面的登录。 1sudo apt-get install xrdp 安装完成后，使用ifconfig获得本地ip地址，然后使用windows进行远程登陆。在未进行配置之前，使用默认的密码进行初次登录pi bananapi 考虑到此开发板的后期应用场景，需要对此进行精简rom，作为一个单纯的服务端来使用，去除没有必要的组件。 精简操作 删除Games1rm -rf python-games 删除opt目录下的示范代码1sudo rm -rf opt 移除IBM的Node-RED、Mathematica、Scratch、Sonic Pi、Minecraft Pi1sudo apt-get remove --purge --auto-remove nodered wolfram-engine scratch sonic-pi minecraft-pi 移除掉Sense HAT Emulator1sudo apt-get remove --purge --auto-remove python-sense-emu python3-sense-emu python-sense-emu-doc sense-emu-tools 移除Libre Office(后边的*意思是全部移除)1sudo apt-get remove --purge --auto-remove libreoffice* 移除掉浏览器(保留谷歌浏览器,因为项目中用到了谷歌浏览器)1sudo apt-get remove --purge --auto-remove claws-mail rpi-chromium-mods epiphany-browser dillo 移除两套Java IDE：BlueJ与Greenfoot，一套轻量型IDE：Geany1sudo apt-get remove --purge --auto-remove bluej greenfoot geany 执行清洁12sudo apt-get autoremovesudo apt-get clean 升级固件，让固件支持emmc 5.1 升级bpi-tools12sudo subpi-tools 下载升级固件驱动1bpi-update -c bpi-m2p.conf 检查下载的文件格式1file *.tgz 生成bootloader1bpi-bootsel bootloader 生成后将会出现地址 升级bootloader1bpi-bootsel /usr/lib/u-boot/bananapi/bpi-m2p/BPI_M2P_720P.img.gz 使用生成的bootloader 重启1reboot 生成自己的ROMhttp://forum.banana-pi.org/t/how-to-use-bpi-tools-migrate-command-to-build-yourself-image/2019 http://wiki.banana-pi.org/Getting_Started_with_M2P#Load_your_image_on_M2P_EMMC 参考了这两个链接。","link":"/2020/01/19/Friendly-BananaPi-Raspberry/"},{"title":"热水器改造项目","text":"生活上有一个不便之处是关于热水器的使用，说到这里，务必劝解各位，🤐买房一定不要买☠️万科☠️。 因为热水器🚿是配套赠送的，暂时没有更换的需求，热水器是力诺瑞特电热和太阳能混合的，保证了天气不好的时候可以使用电加热，但是电加热非常不方便，尤其在这个被物联网时代惯坏了时代。在外没法看到热水器的温度显示。想着实现如下功能： 远程观看热水器水温 远程（手机）可点击热水器的加热按钮 在家时候使用天猫精灵进行开启和关闭加热 硬件准备 手里有树莓派、esp32、esp8266和好多开发板，综合考虑使用一块友善之臂的开发板，但是友善之臂开发板的固件非常的不友善，看了一下采用了H3的soc，对比了一下国内有好几家有类似的方案，orangePi,BananaPi,发现香蕉派的M2和友善之臂M1 Plus有着惊人的相似之处，连引脚定义都是相同的，但是香蕉派的固件明显的要友善一些，单从固件大小上就能看出，友善之臂没有打包很多的驱动在内。 尝试将BananaPi的固件刷入友善之臂，竟然完美兼容。😂 要实现温度的读取，如果从热水器内部下手，担心丢失保修，只能从外部下手，使用大的摄像头担心浪费，买了一个esp32-cam模块来拍摄温度显示，然后写个图像的ocr识别来曲线救国。 加热按钮考虑使用舵机来实现模拟人工的按键 数据中心使用Domoticz 树莓派安装Domoticz非常方便 12sudo curl -L install.domoticz.cn | sudo bashsudo apt-get update 运行以上命令后就会进入domoticz的配置界面。 流程图 12345678910participant 客户端 as Aparticipant esp32CAM as Bparticipant 数据中心 as CNote over A:用户账号、密码A-&gt;C: 访问数据中心Note over C:验证账号、密码C--&gt;&gt;A:热水器温度状态A-&gt;C:发送指令C--&gt;&gt;B:发送指令B-&gt;B:自交互 未完待续… 尤其是济南华艺黄运林这个老板经营的地产项目，绝对是坑，项目要配套没有配套在济南开发的这些项目都是合作开发，狗血的是作为万科济南负责人竟然自己注册了个华艺地产，万科和华艺合作。","link":"/2020/01/14/Friendly-Arm/"},{"title":"android-command","text":"每个拥有android手机的人必须要会几条ADB Commands. 掌握一下命令行通过中间人的方式，你的同事的手机如果root过或者在公共场合，可以随意查看他们手机中的资料。所以对于android手机root就等于开放。 ADB = Android Debug Bridge ADB命令有很多，整理一下几条比较常用的如下： 1.查看版本 123$abd versionAndorid Debug Bridge version 1.0.36Revision 8F855A3D9B35-android 2.查看连接设备 123$adb devicesof devices attached02ae0c1021089daf device ``` 3.安装 1adb install 保留数据和缓存文件，重新安装apk： adb install -r安装apk到sd卡： 1adb install -s 4.卸载 12adb uninstall \\\\eg：adb uninstall com.stormzhang.demo 卸载app但保留数据和缓存文件 1adb uninstall -k 5.启动/停止Server 启动Server 1adb start-server 停止Server 1adb kill-server 6.包管理 列出手机装的所有app的包名 1adb shell pm list packages 列出系统应用的所有包名 1adb shell pm list packages -s 列出第三方应用： 1adb shell pm list packages -3 使用grep来过滤 1adb shell pm list packages | grep qq 7.清除应用数据及缓存 1adb shell pm clear 8.启动应用 1adb shell am start -n /.ui.SplashActivity 9.强制停止应用 1adb shell am force-stop 10.查看日志 1adb logcat 11.重启 1adb reboot 12.获取序列号 1$adb get-serialno 13.获取MAC地址 1$adb shell cat /sys/class/net/wlan0/address 14.查看设备型号 1adb shell getprop ro.product.model 15.查看Android系统版本 1$adb shell getprop ro.build.version.release 16.查看屏幕分辨率 1$adb shell wm size 17.检查设备是否已经ROOT 12adb shellsu 18.开启关闭wifi（需ROOT权限） 12adb rootadb shell svc wifi enable/disable 19.音量控制 1adb shell input keyevent 24/25、164 24增加音量，25降低音量 164 静音 20.文件管理 复制电脑里的文件到设备 1adb push &lt;电脑文件路径&gt; &lt;设备里的目录&gt; 复制设备文件到电脑 1adb pull /sdcard/sr.mp4 ~/tmp","link":"/2017/03/01/android-command/"},{"title":"Matplotlib常见问题","text":"最近接了不少学生作业大多数都是预测和数据分析以及分类器相关，所用图表展示用到Matplotlib，经常会涉及到一些问题，对出现的问题进行整理，避免重复踩坑。 中文显示乱码问题图表展示，图例等标识都需要用到中文，如果MATPLOTLIB缺少中文字体的调用，图表显示的时候会出现乱码。 123456789import numpy as npimport matplotlibimport matplotlib.pyplot as pltfrom matplotlib.figure import Figure# 正常显示画图时出现的中文和负号from pylab import mplmpl.rcParams['font.sans-serif']=['SimHei']mpl.rcParams['axes.unicode_minus']=False tight_layout()Matplotlib v1.1 引入一个新的命令tight_layout(),用来调整子图参数，使之填充图像区域，解决Axes轴标签、标题、刻度超出图形区域的问题。 1234567891011121314151617181920212223242526272829def show(self): self.figure.tight_layout() FigureCanvasAgg.draw(self) if PORT is None: return if matplotlib.__version__ &lt; '1.2': buffer = self.tostring_rgb(0, 0) else: buffer = self.tostring_rgb() if len(set(buffer)) &lt;= 1: # do not plot empty return render = self.get_renderer() width = int(render.width) plot_index = index if os.getenv(\"PYCHARM_MATPLOTLIB_INTERACTIVE\", False) else -1 try: sock = socket.socket() sock.connect((HOST, PORT)) sock.send(struct.pack('&gt;i', width)) sock.send(struct.pack('&gt;i', plot_index)) sock.send(struct.pack('&gt;i', len(buffer))) sock.send(buffer) except OSError as _: # nothing bad. It just means, that our tool window doesn't run yet pass 当axes列表为空的时候,tight_layout()将会报错，此时需要将plt.show()替换为plt.savefig(‘file.png’,bbox_inches=’tight’)","link":"/2020/01/10/Matplotlib/"},{"title":"2019书单计划","text":"转眼间2019已经过去快一半的时间了，想到年初立的flag 虽然在做却没有及时的总结和复盘。今天把今年需要读的书单发出来，以提醒自己。 月亮与六便士 刻意练习 动物农场 时间管理 微习惯 微精通 极简工作法 技术类精通Scrapy网络爬虫 精通Python爬虫框架Scrapy 编程珠玑 编写可维护的JavaScript Python编程无师自通 MicroPython for the Internet of Things 图解HTTP 其他极客物理学 理财类穷查理宝典 语言类1368个单词就够了 另外还有eslpod 和englipod的音频 反复练习读听写 todo list 精通Scrapy网络爬虫 圣斗士星矢 万历十五年 动物农场（中文） 日语五十音图详解","link":"/2019/04/24/booklist/"},{"title":"bigbang","text":"关于Big Bang!前几天看老罗的新品发布会 M1 M1L(据说谐音是满意和满意了)发现新的Smartisan OS 3.0系统里面的Big Bang功能有点像前几天研究的分词。 今天晚上在T1上也受到了OTA的升级推送，体验了一下新版的3.0系统，发现Big Bang 功能的触摸体验不是很好，额 有点偏离主题了。 今天我们来做一下用python实现Big Bang的功能。这里需要用到一个开源的Module，jieba（结巴），可以使用pip进行安装pip install jieba 使用方法： -*- coding:utf-8 -*-123import jiebaseg_list = jieba.cut(“我来到山东大学”, cut_all = True)print “Full Mode:”, ‘ ‘.join(seg_list) #Full Mode: 我 来到 山东 山东大学 东大 大学 #感觉这个分词模式可以用到搜索引擎的优化，得到用户可能搜索的意图seg_list = jieba.cut(“周末可以去帮吱吱搬家”)print “Default Mode:”, ‘ ‘.join(seg_list) #Default Mode: 周末 可以 去 帮 吱吱 搬家↑这个结果完全和Big Bang的爆炸效果完全一样","link":"/2016/10/26/bigbang/"},{"title":"beautifulsoup-useage","text":"之前混合使用bs4、re、lxml 这三个Modules进行解析html的方式虽然可以解决问题但是明显的影响了响应速度，突然发现BS4可以使用CSS Selector方式类似与Xpath的解析。 通过Chrome或者FF 得到tag的CSS Selector 路径使用select可以直接进行使用，明显的代码少了很多行，而且执行速度大大提升。","link":"/2016/09/08/beautifulsoup-useage/"},{"title":"30-years-old","text":"如果生活是大海，那么其中的每天就像海浪，有的震撼，有的普通。 每年的反省都会发现很多让自己后悔不已的事情，往事并不如烟。 相信命 信命不是极致的悲观、灰暗和迷信，而是理性又成熟深刻的价值观，知道山外有山，才能更加云淡风轻，每个人的起跑线不一样，个体的差异不因意志转移而改变，尊重客观事实才能更好的活自己。 信息差 都说现在互联网时代了，没有什么信息查和信息壁垒，其实信息差永远存在。这一点如果认识的更早一些就好了。天下所有靠培训教育来盈利的都是靠的信息差。 不要把所有的鸡蛋都放在一个篮子里 不要等到拥有几十万再去理财，把收入分成几份，消费，应急，储蓄，年轻的时候不要折腾股票和其他投资，在你认知不能驾驭你所有用的时候，这些拥有都将成为失去，老实把钱存起来，钱多一些，你的自信会更多一些，思维会越来越广。 降低自我预期的阈值 没有人能随便成功，降低预期能让自己好过不少，至少失败的时候能舒服一些，学会接受失败面对现实。 家庭合伙制是婚宴的本质 性格好的女人比漂亮、有才、有钱之类更加优势明显。 不要和老板做朋友 如果和老板称兄道弟，表面越好，后面撕逼就更严重。开始很美丽，结束没道理。 少买或者不买付费知识课程 90%的课程本质上都是垃圾，对你没有任何好处，所有的方法论和成功方式都不适合你，基本连可应用的场景都没有，知识付费本质上是贩卖焦虑，收智商税。省下这些时间读几本经典的书并总结。 买保险 保险是你人生变故后的最后一根救命稻草。 学习一项特长 趁早刻意练习，特长能够让你保持足够的竞争力和优势。 及时止损 错了就是错了，失败了就是失败了，及时抽离。 锻炼身体 这世界是你的，但最终是哪些身体好的。 享受孤独，学会独立思考 孤独并不可耻，每个人都是孤独的，只有自己了解自己。 创业 多去折腾，选择别人而不是被别人选择。 自信坚持 自信能让你获得更多的资源和快感。","link":"/2020/02/28/30-years-old/"},{"title":"Use Cloudflare as Dynamic DNS with Raspberry Pi","text":"pi-hole、Domoticz、Homebridge都已经安装好了，是时候设置个域名了，考虑到Cloudflare的强大，此次的DDNS将使用Cloudflare来实现。 Cloudflare 控制台配置1️⃣ 登录cloudflare控制台。2️⃣ 添加你要进行解析的域名3️⃣ 添加一条默认的A记录，指向一个ipv4的地址。 Global API Key如果使用动态域名，需要使用全局apikey来登录更新A记录的值 在CloudFlare管理后台登录个人面板 向下滑动找到全局api 记录下api后边使用 在树莓派上面配置 DDclient⚠️ 安装完成后需要跳过设置界面，因为后面需要覆盖此配置。12sudo apt-get updatesudo apt-get install ddclient libjson-any-perl 更新ddclient最新版的ddclient能够更好的支持cloudflare12wget https://files.pimylifeup.com/portforwarding/ddclient-3.9.0.tar.gztar -zxvf ddclient-3.9.0.tar.gz 替换已经安装的路径1sudo cp -f ddclient-3.9.0/ddclient /usr/sbin/ddclient 因为新版的ddclient 做了更改，所以我们需要在原版基础上修改一下文件位置12sudo mkdir /etc/ddclientsudo mv /etc/ddclient.conf /etc/ddclient 修改配置文件1sudo vi /etc/ddclient/ddclient.conf 将下列配置添加到文件当中123456protocol=cloudflareserver=www.cloudflare.comlogin=CLONDFLARE_LOGIN_MAIL #此处填写你的cf登录邮箱password=GLOBAL_API_KEY #此处填写上面拿到的cf密钥zone=YOUR_DOMAIN.COM #填写你的域名地址anything.YOUR_DOMAIN.COM #配置的域名地址 重启服务1sudo /etc/init.d/ddclient restart","link":"/2020/01/20/dynamicDNS/"},{"title":"编程代码字体","text":"说到字体，之前看过西蒙·加菲尔德的《字体故事》非常不错的一本书，没有看过可以看看👉字体故事。字体真的是非常重要的基础设施。但凡是能够接触到信息除了口口相传，就一定能接触到字体。 最近不少大公司开始放出免费的为编程人员使用的字体，感谢。 MS家专为新的终端程序设计的Cascadia Code. 美国政府在U.S. Web Design System设计的Public Sans IBM为灵感设计的 IBM Plex Highway Gothic 为灵感设计的Overpass Font Jet Brains设计的Monospaced Font 以上字体都可以免费使用，不用担心版权问题。 MS Cascadia Code This is a fun, new monospaced font that includes programming ligatures and is designed to enhance the modern look and feel of the Windows Terminal. Download👉link 美国政府公布的原始码字形，修改自经典英文字体LibreFranklin Font的开源版本，比原有字体更清晰，对屏幕阅读有更好的易读性。 Public Sans 提供各种字型厚度，font-weight 从100-900，包含italic，无论是标题还是内文都有非常好的表现。 download👉link IBM Plex IBM Plex Family 由三大字体类型组成，Sans-serif，Serif和Mono，除了提供8中字重外，IBM Plex也提供了网页使用的eot woff, woff2格式 官网👉link Download 👉link Overpass Font Overpass设计灵感来自联邦高速公路字体，美国、加拿大、土耳其、澳大利亚、荷兰、中国都是使用联邦高速公路字体，不过现在部分地区已经使用Clearview替代。 官网地址 Monospaced Font JetBrains Mono 比一般的等宽字体来说增加了字体高度以提升阅读体验，更適合做变成代码使用，除了节省空间，也减少眼睛处理的时间。 官网地址 👉link","link":"/2020/02/28/fonts-for-developers/"},{"title":"domain-name-servers","text":"dns在平时上网中扮演重要角色，如果不注意dns的话，可能会导致网速慢，弹窗广告，网址打不开，打开的不是自己想要的网站，劫持，抢中抢等一系列问题。针对dns的问题，今天我们来总结一下，看看哪家dns服务器最好用。 以下常见问题可通过修改dns解决。1.电脑只能上QQ，不能访问网页。2.iphone手机访问appstore非常慢。3.打开某网站速度非常慢。 DNSPod DNS+：★★★★★（推荐）DNSPod的 Public DNS+是目前国内第一家支持ECS的公共DNS，是DNSPod推出的公共域名解析服务，可以为全网用户提供域名的公共递归解析服务！DNS 服务器 IP 地址：首选：119.29.29.29备选：182.254.116.116作者点评：测试数据显示Public DNS+国内数据均比114DNS好，强力推荐！ 114DNS：★★★★★国内用户量巨大的DNS，访问速度快，各省都有节点，同时满足电信、联通、移动各运营商用户，可以有效预防劫持。DNS 服务器 IP 地址：首选：114.114.114.114备选：114.114.114.115作者点评：虽然测试结果比不上Public DNS+理想，但是也是非常不错的DNS！ 阿里 AliDNS：★★★★阿里公共DNS是阿里巴巴集团推出的DNS递归解析系统，目标是成为国内互联网基础设施的组成部分，面向互联网用户提供“快速”、“稳定”、“智能”的免费DNS递归解析服务。DNS 服务器 IP 地址：首选：223.5.5.5备选：223.6.6.6作者点评：排名第三的DNS也不是吹的，只是节点貌似有点少。 DNS派：★★★★DNS派是聚流科技旗下的DNS服务平台,为个人用户、网站主、企业提供各种有关DNS业务的服务,包括个人上网的域名解析服务、网站授权解析服务、企业域名解析服务等。DNS 服务器 IP 地址：首选（电信/移动/铁通）：101.226.4.6备选（电信/移动/铁通）：218.30.118.6首选（联通）：123.125.81.6备选（联通）：140.207.198.6作者点评：360出品！测试结果还不错！ 百度 BaiduDNS：★★★百度DNS旗下云解析服务,依托百度一流基础设施和强大技术实力,为用户提供免费的、超越竞品的服务体验。没有套餐区分,安全,稳定,高效DNS 服务器 IP 地址：首选：180.76.76.76作者点评：暂时不知道百度有多少节点。不过应该也不少吧。 CNNIC SDNS：★★★SDNS是由中国互联网络信息中心(CNNIC)正式推出的免费的公共云解析服务(SecureDNS,简称SDNS)。该服务可为广大网民提供安全、智能、高速的上网接入解析服务。DNS 服务器 IP 地址：首选：1.2.4.8备选：210.2.4.8作者点评：作为国家出品的DNS，有待测试……（你敢用吗？反正我不敢） OpenDNS：★（不推荐）OpenDNS是一个免费的域名解析服务提供商（DNS）。创建于2006年，长期以来致力于为广大个人用户以及商务企业用户和公共领域提供免费的域名解析服务。DNS 服务器 IP 地址：首选：208.67.222.222备选：208.67.220.220作者点评：国内节点少！貌似就几个，不推荐使用！ Google DNS：★（强烈不推荐）谷歌公共域名解析服务（Google Public DNS）是由谷歌公司于2009年发布的一项新的DNS服务。主要为了替代ISPs或其他公司提供的DNS服务。DNS 服务器 IP 地址：首选：8.8.8.8备选：8.8.4.4作者点评：机房在国外，国内无节点！你如果用了谷歌DNS你的信息有可能会免费出国转一圈才回来！强烈不推荐使用！只适合国外用户使用！","link":"/2017/05/16/domain-name-servers/"},{"title":"金庸武侠小说大全-电子版下载","text":"飞雪连天射白鹿，笑书神侠倚碧鸳，感谢查老带来的经典武侠作品，虽然没有读过几本，在大家读金庸的时候相同的时间我给了韩寒、苏童、王小波、路遥还有一系列的《电脑报》、《萌芽》、《Hacker X档案》 《黑客防线》等书籍，以下为整理的金庸武侠大全电子版，供大家下载： 《飞狐外传》 《雪山飞狐》 《连城诀》 《天龙八部》 《射雕英雄传》 《白马啸西风》 《鹿鼎记》 《笑傲江湖》 《书剑恩仇录》 《神雕侠侣》 《侠客行》 《倚天屠龙记》 《碧血剑》 《鸳鸯刀》 《越女剑》 电子书说明 TXT版本 txt版本下载 插图版 插图版下载 PDF三联 PDF版下载","link":"/2018/11/05/hero-novel/"},{"title":"Python-ticks","text":"整理和维护经常会用到的python技巧 Upack 当需要从某个可迭代对象中分决出N个元素，但是这个可迭代对象的长度可能超过N，这会导致“分解的值过多（too many values to unpack）”的异常 解决方案 使用python的“*表达式”可以解决这个问题。 123def drop_first_last(grades): first,*middle,last = grades return avg(middle) 在分解任意长度的可迭代对象时特别好用 1234567891011121314records =[ ('foo',1,3), ('bar','hello'), ('foo',3,4),]def do_foo(x,y): print('foo',x,y)def do_bar(s): print('bar',s)for tag,*args in records: if tag=='foo': do_foo(*args) elif tag=='bar': do_bar(*args) 步进切片从列表中创建一定间隔的新列表 1234567&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a[::2][0, 2, 4, 6, 8, 10]&gt;&gt;&gt; a[::3][0, 3, 6, 9]&gt;&gt;&gt; a[2:8:2][2, 4, 6] list slice with step (a[start:end:step]) 生成倒叙的list 12345&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a[::-1][10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]&gt;&gt;&gt; a[::-2][10, 8, 6, 4, 2, 0] 命名切片的调用Naming slices (slice(start,end,step)) 123456&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5]&gt;&gt;&gt; LASTTHREE = slice(-3, None)&gt;&gt;&gt; LASTTHREEslice(-3, None, None)&gt;&gt;&gt; a[LASTTHREE][3, 4, 5] 遍历列表的索引和值Iterating over list index and value pairs (enumerate) 1234567&gt;&gt;&gt; a = ['Hello', 'world', '!']&gt;&gt;&gt; for i, x in enumerate(a):... print '{}: {}'.format(i, x)...0: Hello1: world2: ! 遍历字典dict.iteritems 12345678&gt;&gt;&gt; m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}&gt;&gt;&gt; for k, v in m.iteritems():... print '{}: {}'.format(k, v)...a: 1c: 3b: 2d: 4 压缩和解压缩列表Zipping and unzipping lists 1234567&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = ['a', 'b', 'c']&gt;&gt;&gt; z = zip(a, b)&gt;&gt;&gt; z[(1, 'a'), (2, 'b'), (3, 'c')]&gt;&gt;&gt; zip(*z)[(1, 2, 3), ('a', 'b', 'c')] 使用zip分组相邻的列表项Grouping adjacent list items using zip 1234567891011121314151617181920&gt;&gt;&gt; # Using iterators&gt;&gt;&gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))&gt;&gt;&gt; group_adjacent(a, 3)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent(a, 2)[(1, 2), (3, 4), (5, 6)]&gt;&gt;&gt; group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)]&gt;&gt;&gt; # Using slices&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; group_adjacent = lambda a, k: zip(*(islice(a, i, None, k) for i in range(k)))&gt;&gt;&gt; group_adjacent(a, 3)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent(a, 2)[(1, 2), (3, 4), (5, 6)]&gt;&gt;&gt; group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)] 使用滑动窗口迭代器Sliding windows (nn -grams) using zip and iterators 123456789101112&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; def n_grams(a, n):... z = (islice(a, i, None) for i in range(n))... return zip(*z)...&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; n_grams(a, 3)[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]&gt;&gt;&gt; n_grams(a, 2)[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]&gt;&gt;&gt; n_grams(a, 4)[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)] 字典的键值反转Inverting a dictionary using zip 12345678&gt;&gt;&gt; m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}&gt;&gt;&gt; m.items()[('a', 1), ('c', 3), ('b', 2), ('d', 4)]&gt;&gt;&gt; zip(m.values(), m.keys())[(1, 'a'), (3, 'c'), (2, 'b'), (4, 'd')]&gt;&gt;&gt; mi = dict(zip(m.values(), m.keys()))&gt;&gt;&gt; mi{1: 'a', 2: 'b', 3: 'c', 4: 'd'} 展开列表Flattening lists 1234567891011121314&gt;&gt;&gt; a = [[1, 2], [3, 4], [5, 6]]&gt;&gt;&gt; list(itertools.chain.from_iterable(a))[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; sum(a, [])[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; [x for l in a for x in l][1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]&gt;&gt;&gt; [x for l1 in a for l2 in l1 for x in l2][1, 2, 3, 4, 5, 6, 7, 8]&gt;&gt;&gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]&gt;&gt;&gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]&gt;&gt;&gt; flatten(a)[1, 2, 3, 4, 5, 6, 7, 8] 生成器表达式Generator expressions 12345678910111213&gt;&gt;&gt; g = (x ** 2 for x in xrange(10))&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; sum(x ** 3 for x in xrange(10))2025&gt;&gt;&gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)408 字典推导式Dicitonary comprehensions 123456&gt;&gt;&gt; m = {x: x ** 2 for x in range(5)}&gt;&gt;&gt; m{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}&gt;&gt;&gt; m = {x: 'A' + str(x) for x in range(10)}&gt;&gt;&gt; m{0: 'A0', 1: 'A1', 2: 'A2', 3: 'A3', 4: 'A4', 5: 'A5', 6: 'A6', 7: 'A7', 8: 'A8', 9: 'A9'} 使用字典推到式反转字典Inverting a dictionary using a dictionary comprehension 12345&gt;&gt;&gt; m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}&gt;&gt;&gt; m{'d': 4, 'a': 1, 'b': 2, 'c': 3}&gt;&gt;&gt; {v: k for k, v in m.items()}{1: 'a', 2: 'b', 3: 'c', 4: 'd'} 命名元组的调用Named tuples (collections.namedtuple) 12345678&gt;&gt;&gt; Point = collections.namedtuple('Point', ['x', 'y'])&gt;&gt;&gt; p = Point(x=1.0, y=2.0)&gt;&gt;&gt; pPoint(x=1.0, y=2.0)&gt;&gt;&gt; p.x1.0&gt;&gt;&gt; p.y2.0 从命名元组继承inheriting from named tuples 12345678&gt;&gt;&gt; class Point(collections.namedtuple('PointBase', ['x', 'y'])):... __slots__ = ()... def __add__(self, other):... return Point(x=self.x + other.x, y=self.y + other.y)&gt;&gt;&gt; p = Point(x=1.0, y=2.0)&gt;&gt;&gt; q = Point(x=2.0, y=3.0)&gt;&gt;&gt; p + qPoint(x=3.0, y=5.0) 集合的使用sets and set operations 123456789101112131415161718&gt;&gt;&gt; A = {1, 2, 3, 3}&gt;&gt;&gt; Aset([1, 2, 3])&gt;&gt;&gt; B = {3, 4, 5, 6, 7}&gt;&gt;&gt; Bset([3, 4, 5, 6, 7])&gt;&gt;&gt; A | Bset([1, 2, 3, 4, 5, 6, 7])&gt;&gt;&gt; A &amp; Bset([3])&gt;&gt;&gt; A - Bset([1, 2])&gt;&gt;&gt; B - Aset([4, 5, 6, 7])&gt;&gt;&gt; A ^ Bset([1, 2, 4, 5, 6, 7])&gt;&gt;&gt; (A ^ B) == ((A - B) | (B - A))True 集合的操作 12345678910111213141516&gt;&gt;&gt; A = collections.Counter([1, 2, 2])&gt;&gt;&gt; B = collections.Counter([2, 2, 3])&gt;&gt;&gt; ACounter({2: 2, 1: 1})&gt;&gt;&gt; BCounter({2: 2, 3: 1})&gt;&gt;&gt; A | BCounter({2: 2, 1: 1, 3: 1})&gt;&gt;&gt; A &amp; BCounter({2: 2})&gt;&gt;&gt; A + BCounter({2: 4, 1: 1, 3: 1})&gt;&gt;&gt; A - BCounter({1: 1})&gt;&gt;&gt; B - ACounter({3: 1}) 可迭代对象的计数 1234567&gt;&gt;&gt; A = collections.Counter([1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 6, 7])&gt;&gt;&gt; ACounter({3: 4, 1: 2, 2: 2, 4: 1, 5: 1, 6: 1, 7: 1})&gt;&gt;&gt; A.most_common(1)[(3, 4)]&gt;&gt;&gt; A.most_common(3)[(3, 4), (1, 2), (2, 2)] 双端队列double-ended queue 12345678910111213141516171819&gt;&gt;&gt; Q = collections.deque()&gt;&gt;&gt; Q.append(1)&gt;&gt;&gt; Q.appendleft(2)&gt;&gt;&gt; Q.extend([3, 4])&gt;&gt;&gt; Q.extendleft([5, 6])&gt;&gt;&gt; Qdeque([6, 5, 2, 1, 3, 4])&gt;&gt;&gt; Q.pop()4&gt;&gt;&gt; Q.popleft()6&gt;&gt;&gt; Qdeque([5, 2, 1, 3])&gt;&gt;&gt; Q.rotate(3)&gt;&gt;&gt; Qdeque([2, 1, 3, 5])&gt;&gt;&gt; Q.rotate(-3)&gt;&gt;&gt; Qdeque([5, 2, 1, 3]) 最大长度双端队列double-ended queue with maximum length 123456789101112131415&gt;&gt;&gt; last_three = collections.deque(maxlen=3)&gt;&gt;&gt; for i in xrange(10):... last_three.append(i)... print ', '.join(str(x) for x in last_three)...00, 10, 1, 21, 2, 32, 3, 43, 4, 54, 5, 65, 6, 76, 7, 87, 8, 9 有序字典ordered dictionaries 123456789&gt;&gt;&gt; m = dict((str(x), x) for x in range(10))&gt;&gt;&gt; print ', '.join(m.keys())1, 0, 3, 2, 5, 4, 7, 6, 9, 8&gt;&gt;&gt; m = collections.OrderedDict((str(x), x) for x in range(10))&gt;&gt;&gt; print ', '.join(m.keys())0, 1, 2, 3, 4, 5, 6, 7, 8, 9&gt;&gt;&gt; m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))&gt;&gt;&gt; print ', '.join(m.keys())10, 9, 8, 7, 6, 5, 4, 3, 2, 1 将对象映射到唯一的计数数字mapping objects to unique counting numbers 123456789101112&gt;&gt;&gt; import itertools, collections&gt;&gt;&gt; value_to_numeric_map = collections.defaultdict(itertools.count().next)&gt;&gt;&gt; value_to_numeric_map['a']0&gt;&gt;&gt; value_to_numeric_map['b']1&gt;&gt;&gt; value_to_numeric_map['c']2&gt;&gt;&gt; value_to_numeric_map['a']0&gt;&gt;&gt; value_to_numeric_map['b']1 最大和最小元素largest and smallest elements(heapq.nlargest and heapq.nsmallest) 12345&gt;&gt;&gt; a = [random.randint(0, 100) for __ in xrange(100)]&gt;&gt;&gt; heapq.nsmallest(5, a)[3, 3, 5, 6, 8]&gt;&gt;&gt; heapq.nlargest(5, a)[100, 100, 99, 98, 98] 笛卡尔积cartesian products 1234567891011121314151617181920212223242526&gt;&gt;&gt; for p in itertools.product([1, 2, 3], [4, 5]):(1, 4)(1, 5)(2, 4)(2, 5)(3, 4)(3, 5)&gt;&gt;&gt; for p in itertools.product([0, 1], repeat=4):... print ''.join(str(x) for x in p)...0000000100100011010001010110011110001001101010111100110111101111 组合和替换组合combinations and combinations with replacemnet 12345678910111213141516171819202122&gt;&gt;&gt; for c in itertools.combinations([1, 2, 3, 4, 5], 3):... print ''.join(str(x) for x in c)...123124125134135145234235245345&gt;&gt;&gt; for c in itertools.combinations_with_replacement([1, 2, 3], 2):... print ''.join(str(x) for x in c)...111213222333 排列交换Permurtations 123456789101112131415161718192021222324252627&gt;&gt;&gt; for p in itertools.permutations([1, 2, 3, 4]):... print ''.join(str(x) for x in p)...123412431324134214231432213421432314234124132431312431423214324134123421412341324213423143124321 链式迭代chaining iterables 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; a = [1, 2, 3, 4]&gt;&gt;&gt; for p in itertools.chain(itertools.combinations(a, 2), itertools.combinations(a, 3)):... print p...(1, 2)(1, 3)(1, 4)(2, 3)(2, 4)(3, 4)(1, 2, 3)(1, 2, 4)(1, 3, 4)(2, 3, 4)&gt;&gt;&gt; for subset in itertools.chain.from_iterable(itertools.combinations(a, n) for n in range(len(a) + 1))... print subset...()(1,)(2,)(3,)(4,)(1, 2)(1, 3)(1, 4)(2, 3)(2, 4)(3, 4)(1, 2, 3)(1, 2, 4)(1, 3, 4)(2, 3, 4)(1, 2, 3, 4) 按给定键进行分组grouping rows by a given key 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; import itertools&gt;&gt;&gt; with open('contactlenses.csv', 'r') as infile:... data = [line.strip().split(',') for line in infile]...&gt;&gt;&gt; data = data[1:]&gt;&gt;&gt; def print_data(rows):... print '\\n'.join('\\t'.join('{: &lt;16}'.format(s) for s in row) for row in rows)...&gt;&gt;&gt; print_data(data)young myope no reduced noneyoung myope no normal softyoung myope yes reduced noneyoung myope yes normal hardyoung hypermetrope no reduced noneyoung hypermetrope no normal softyoung hypermetrope yes reduced noneyoung hypermetrope yes normal hardpre-presbyopic myope no reduced nonepre-presbyopic myope no normal softpre-presbyopic myope yes reduced nonepre-presbyopic myope yes normal hardpre-presbyopic hypermetrope no reduced nonepre-presbyopic hypermetrope no normal softpre-presbyopic hypermetrope yes reduced nonepre-presbyopic hypermetrope yes normal nonepresbyopic myope no reduced nonepresbyopic myope no normal nonepresbyopic myope yes reduced nonepresbyopic myope yes normal hardpresbyopic hypermetrope no reduced nonepresbyopic hypermetrope no normal softpresbyopic hypermetrope yes reduced nonepresbyopic hypermetrope yes normal none&gt;&gt;&gt; data.sort(key=itemgetter(-1))&gt;&gt;&gt; for value, group in itertools.groupby(data, lambda r: r[-1]):... print '-----------'... print 'Group: ' + value... print_data(group)...-----------Group: hardyoung myope yes normal hardyoung hypermetrope yes normal hardpre-presbyopic myope yes normal hardpresbyopic myope yes normal hard-----------Group: noneyoung myope no reduced noneyoung myope yes reduced noneyoung hypermetrope no reduced noneyoung hypermetrope yes reduced nonepre-presbyopic myope no reduced nonepre-presbyopic myope yes reduced nonepre-presbyopic hypermetrope no reduced nonepre-presbyopic hypermetrope yes reduced nonepre-presbyopic hypermetrope yes normal nonepresbyopic myope no reduced nonepresbyopic myope no normal nonepresbyopic myope yes reduced nonepresbyopic hypermetrope no reduced nonepresbyopic hypermetrope yes reduced nonepresbyopic hypermetrope yes normal none-----------Group: softyoung myope no normal softyoung hypermetrope no normal softpre-presbyopic myope no normal softpre-presbyopic hypermetrope no normal softpresbyopic hypermetrope no normal soft 在任意目录中启动http服务器 start a static http server in any directory 1python -m SimpleHTTPServer 5000","link":"/2019/12/25/decomposing-elements-from-iteratable-objects-md/"},{"title":"0.96 OLED Display","text":"之前买过一个0.96英寸的OLED屏幕，一直没有用，最近想着做个小的玩具，比如放在桌面上的小摆件可以提醒生词，提醒todo-list等，或者结合esp8266做成一个情侣见互相留言的小玩具。 ##关于OLED OLED，即有机发光二极管( OrganicLightEmittingDiode)。 OLED 由于同时具备自发光，不需背 光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及 制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。LCD 都需要背光，而 OLED 不需要，因为它是自发光的。这样同样的显示 OLED 效果要来得好一些。 说说踩过的坑1.因为使用Micropython，可以参考的资料非常少。 2.这个OLED本身不带字库，除了英文和标准绘图（点、线、形状）之外都需要使用其他方式实现。 3.依赖SSD1306驱动，不能像Arduino的u8g2库一样强大，许多功能需要自己实现。 ##中文文字转字模型所有显示的中文都需要转换成字模，其实在购买屏幕的时候随机送了一个中文取字模的软件。PCtoLCD2002，但是我用的是Mac，总不能为了这个字模装个虚拟机吧，虽然我将另外一台win10开启了远程桌面，但是也不便于形成Demo后别人使用，在有网环境下可以用我写的一个小脚本fontool.可以方便的将想要显示的中文转换为字模。 ##图片显示关于图片的显示，网上有两种方案（基于Arduino）一种是将图片转换为二进制bin文件，另一种和中文差不多，将图片的像素转换为01二进制，0为不现实1为亮。没有现成的库。 ###实现图片的显示以我的头像这个dogydog为例。这里需要用的的python库 PIL （Pillow） 1.首先将图片处理为灰度模式，然后改变图像的大小，这里有个坑，其实你直接使用PIL的resize就好但是网上的多处例子谈到img = img.resize((w,h),Image.ANTIALIAS) 这个地方的Image.ANTIALIAS其实是用来处理大型图片缩放时候用到的一个滤镜，对比PS的文件处理速度会快一些而且质量会好一些，在应用与低质量的显示比如这块128 * 64的屏幕上完全用不到精细化处理，而且会适得其反，因为8266的内存有限，使用滤镜生成的bin文件会很大，而且在128*64这样的屏幕上会有毛刺。 对比效果 2.然后逐行的读取每个像素点的数值，生成10矩阵。代码在这里 显示效果","link":"/2019/02/26/oled-display/"},{"title":"Markdown Awesome","text":"` ` 在markdown文章张使用图标装饰在之前的工作中制作原型，包括上一篇文章中用到的iconfont的图标，每次都要处理多次。看到bootstrap的教程中使用@face-font 可以使用图标，突然想到markdown能否直接调用iconfont、fontawesome的图标？网上一搜果然是有的，像我一样的懒人在我之前就存在。 准备工作Font Awesome是一个字体和图标工具包，包含人物、动物、建筑、商业、品牌、娱乐、动作等等各种主题丰富的图标符号，iconfont也类似起步晚一点是ali旗下的一个开源工具包。 要在markdown文档中输入Font Awesome，需要在文档任意位置输入一下代码调用JavaScript。 12345&lt;head&gt; &lt;script defer src=\"https://use.fontawesome.com/releases/v5.0.13/js/all.js\"&gt;&lt;/script&gt; &lt;script defer src=\"https://use.fontawesome.com/releases/v5.0.13/js/v4-shims.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.2.0/css/all.css\" integrity=\"sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ\" crossorigin=\"anonymous\"&gt; iconFont的使用方法类似，但是区别是，需要将使用的图标先用自己的账号登陆后，收藏然后下载生成的css文件。需要引用本地的css文件。当然灵活性要差一点，必须之前没有收藏某个图标，这下抓瞎了吧。😭生成的css文件格式格式类似如下： //at.alicdn.com/t/font_8d5l8fzk5b87iudi.css 使用方法现在就可以直接插入Font Awesome和iconfont的符号了。 1&lt;i class=\"fa fa-weixin\"&gt;&lt;i&gt; iconfont使用方法类似 1&lt;i class=\"iconfont icon-xxx\"&gt;&lt;/i&gt; 这是表示插入了一个微信图标的符号。 获取符号名称fa-weixin 是微信的\b名称，如何\b调用其他的\b图标呢？在\bawesome 获取后可以保存到LaunchBar中一遍以后方便使用。iconfont 只需要点击收藏就好，在生成的css中可以查询。 调节尺寸1&lt;i class=\"fa fa-weixin\"&gt;&lt;i&gt; 扩展改写为： 1&lt;i class=\"fa fa-weixin fa-2x\"&gt;&lt;i&gt; 可用参数列表：123456fa-xsfa-smfa-lgfa-2x至fa-10x\b### 动画效果\b在class中加入 “fa-spin” 使符号变成连贯转动，加入“fa-pulse”变成8步\b旋转效果。 符号的特殊用法####符号下沉 1234&lt;i class=\"fas fa-quote-left fa-3x fa-pull-left\"&gt;&lt;/i&gt;fa-quote-left 是符号名称fa-3x 表示大小fa-pull-left 符号下沉 上篇文章中所应用到的图标 应该如下正确使用: 小火箭 以上是\bicon的应用，接下来制定自己的学习计划，开始学习Vue.js。","link":"/2018/08/17/markdown-awesome/"},{"title":"google-fire.md","text":"Python Fire is a library for automatically generating command line interfaces (CLIs) from absolutely any Python object. fire 是Google开源的一个python库，能够以简单的方式生成CLI，使得使用REPL更加容易。 安装直接pypi库1pip install fire 使用函数12345import firedef hello(name=\"world\") return 'Hello {name}!'.format(name=name)if __name__ == '__main__': fire.Fire(hello) hello函数接收name参数，并有默认值”world”，使用fire.Fire(hello)即可简单快速的实现命令功能.1234$python hello.pyHello world!$python hello.py --name=RoyHello roy! Class的使用fire支持类的调用方式。123456789import fireclass Calculator(object): def double(self,number): return 2*number def triple(self,number): return 3*numberif __name__ == '__main__': fire.Fire(Calculator) 使用方法1234$python calculator.py double 1020$python calculator.py triple --number=1545 fire的使用非常简单，定义一个对象，剩下的交给fire来处理，it’s very pythonic.","link":"/2020/01/13/google-fire-md/"},{"title":"old-string-formatting","text":"旧式字符串格式化%操作符可以实现字符串格式化。它将左侧的参数作为类似sprintf()式的格式化字符串，而将右侧的代入，然后返回格式化后的字符串。 for example: 123math&gt;&gt;&gt;print('The value of PI is approximately %5.3f.' %math.pi)The value of PI is approximately 3.142 123For example.'The sum of 1 + 2 is 3'str.format_map(mapping) 1234567default(dict): def __missing__(self,key): return key '{name} was born in {country}'.format_map(default(name='Guido'))'Guido war borin in country' str.index(sub[,start[,end]]) Like find(),but raise ValueError when the substring is not found. 区别与find(),find的结果为False时返回-1，index()的查询值如果不在str中，则会报错。 12changxufeng.find('y')//return -1changxufeng.index('y')// ValueError:substring not found str.isalnum() Return true if all characters in the string are alphanumeric and there is at least one character,false otherwise. A character c is alphanumeric if one of the following returns True: c.isalpha(), c.isdecimal(), c.isdigit(), or c.isnumeric(). 如果都是字母和数字时候，return True, else return False. str.isalpha() Return true if all characters in the string are alphabetic and there is at least one character, false otherwise.Alphabetic characters are those characters defined in the Unicode character database as “Letter”,ie.e., those with general category property being one of “Lm”,”Lt”, “Lu”,”Ll” or “Lo” .Note that this is different from the “Alphabetic” propertty defined in the Unicode Standard. 判断str是否都是数字 str.isdecimal() Return true if all characters in the string are decimal characters and there is at least one character,false otherwise.Decimal characters are those from general catefory “Nd”. This category includes digit characters,and all characters that that can be used to form decimal-radix numbers,e.g. U+0660,ARABIC-INDIC DIGIT ZERO. 判断str是否是十进制数。 str.lstrip([chars]) Return a copy of the string with leading characters removed. The chars argument is a string specifying the set of characters to be removed. If omitted orNone, the chars argument defaults to removing whitespace. The chars argument is not a prefix; rather, all combinations of its values are stripped: ' changxufeng'.lstrip()\\当argu为空是，返回结果为去掉str前面的空格。不影响原来str的值，只是一份copy 'changxufeng'.lstrip(chang)\\return ‘xufeng’ 如果去掉首位的空格可以使用str.strip() 'changxufeng'.rstrip('xufeng')\\return ‘cha’ str.title() Return a titlecased version of the string where words start with an uppercase character and the remaining characters are lowercase. The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result: string中首字母大写。","link":"/2018/03/01/old-string-formatting/"},{"title":"播客Feed订阅","text":"🎧 使用 iPhone Safari / Android 系统浏览器，打开本网页，点击下方播客名字，即可添加订阅到播客应用添加到： RSS、 iTunes、 苹果播客、 Overcast、 Castro、 Pocket Casts 看理想《一千零一夜》 看理想《圆桌派》 原来是这样？！ 日谈公园 黑水公园 黑水公园：微信精选推送(微信) 黑水怪谈(微信) 金花漫话(微信) 黑水记(微信) 反派影评 反派影评：耳边风(微信) 反派影评：马后炮(微信) 野史下酒：微信推送 鬼影人间 观复嘟嘟 冬吴同学会 吴晓波频道 诗展侃历史 有话说历史 历史趣谈 大力史 朴素心理学 这事儿我跟你讲 北京话事人 发发大王 齐齐酷咖 糖蒜广播 漫藏道 丁丁说车 王东电台 糗事播报 讨厌在城市读书 游戏时光-VGtime VG聊天室 虎嗅·商业有味道 晓评 读书有疑 静说日本 三联•听周刊 晓说2018 可以谈 婊酱FM 迷失音乐 1UP 播客 友的聊播客 美术史 局座召忠：局座时评(微信) 科学声音龙门阵 36氪·硅谷早知道 第二季 看理想《局部 第一季》 看理想《听说 第一季》","link":"/2018/08/03/podcast/"},{"title":"Python 推送信息到wechat","text":"前言最近看到网上有定时推送文章到微信的文章，其实这个小功能我一直在做，包括定时爬取内容用邮件发送等等。不过网上都是python2.7的版本。对于使用python3的小白可能用起来比较困惑，手动改了一个python3的版本。 #实现环境 python3.6(conda) 数据源：爱词霸 调用地址：http://open.iciba.com/dsapi/ 请求方式：GET 请求参数： 参数 必选 类型 说明 \bdate 否 string 格式为：2018-08-01；默认取当天 type 否 string 可选值为last和next；以date日期为准的last返回前一天，next返回后一天。 代码示例 123456789#coding=utf-8import jsonimport requestsdef get_iciba(): url = 'http://open.iciba.com/dsapi/' request = requests.get(url) data = json.loads(request) #将json转换为dict return dataprint(get_iciba()) 返回类型：JSON (JSON字段解释：) 属性名 属性值类型 说明 sid string 每日一句id tts string 音频地址 content string 英文\b内容 note string 中文内容 love string 每日一句喜欢个数 translation string 词霸小编 picture string 图片地址 picture2 string 大图片地址 caption string 标题 dateline string 时间 s_pv string 浏览数 sp_pv string 语音评测浏览数 tags string 相关标签 fenxiang_img string 合成图片 正常返回示例1{\"sid\":\"3081\",\"tts\":\"http:\\/\\/news.iciba.com\\/admin\\/tts\\/2018-08-02-day.mp3\",\"content\":\"I am just a sunflower, waiting for my only sunshine.\",\"note\":\"我只是一株向日葵，期待着属于自己的那缕阳光。\",\"love\":\"2154\",\"translation\":\"投稿人的话：地球在转，人生再转，但我们对美好爱情的执着永远不会变。我们就像一株向日葵，期待着属于自己的那缕阳光。\",\"picture\":\"http:\\/\\/cdn.iciba.com\\/news\\/word\\/20180802.jpg\",\"picture2\":\"http:\\/\\/cdn.iciba.com\\/news\\/word\\/big_20180802b.jpg\",\"caption\":\"词霸每日一句\",\"dateline\":\"2018-08-02\",\"s_pv\":\"0\",\"sp_pv\":\"0\",\"tags\":[{\"id\":null,\"name\":null}],\"fenxiang_img\":\"http:\\/\\/cdn.iciba.com\\/web\\/news\\/longweibo\\/imag\\/2018-08-02.jpg\"} 登陆微信公众平台借口测试账号\b\b微信公众号测试申请https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 扫描后手机端确认登陆 找到“新增测试模板”，添加\b模板消息填写模板标题“每日一句”（可根据需求自己随便填） 提交后，记住改模版的id，一会用到。 找到测试二维码，扫描后，右侧出现你的昵称和微信号，记录下微信号python程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python#coding=utf-8import jsonimport requestsclass iciba: # 初始化 def __init__(self, wechat_config): self.appid = wechat_config['appid'] self.appsecret = wechat_config['appsecret'] self.template_id = wechat_config['template_id'] self.access_token = '' # 获取access_token def get_access_token(self, appid, appsecret): url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s' % (appid, appsecret) r = requests.get(url) response = r.content.decode() jdata = json.loads(response) access_token = jdata['access_token'] self.access_token = access_token return self.access_token # 发送消息 def send_msg(self, openid, template_id, iciba_everyday): msg = { 'touser': openid, 'template_id': template_id, 'url': iciba_everyday['fenxiang_img'], 'data': { 'content': { 'value': iciba_everyday['content'], 'color': '#0000CD' }, 'note': { 'value': iciba_everyday['note'], }, 'translation': { 'value': iciba_everyday['translation'], } } } jdata = json.dumps(msg) if self.access_token == '': self.get_access_token(self.appid, self.appsecret) access_token = self.access_token url = 'https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=%s' % str(access_token) request = requests.post(url, data=jdata) #response = urllib.request.urlopen(request) result = request.content.decode() return json.loads(result) # 获取爱词霸每日一句 def get_iciba_everyday(self): url = 'http://open.iciba.com/dsapi/' request = requests.get(url) jdata = request.content.decode() data = json.loads(jdata) return data # 为设置的用户列表发送消息 def send_everyday_words(self, openids): everyday_words = self.get_iciba_everyday() for openid in openids: result = self.send_msg(openid, self.template_id, everyday_words) if result['errcode'] == 0: print(' [INFO] send to %s is success' % openid) else: print(' [ERROR] send to %s is error' % openid) # 执行 def run(self, openids): self.send_everyday_words(openids)if __name__ == '__main__': # 微信配置 wechat_config = { 'appid': 'XXXXX', #此处填写你的appid 'appsecret': 'XXXX', #此处填写你的appsecret 'template_id': 'XXXXX' #此处填写你的模板消息ID } # 用户列表 openids = [ 'XXXXXXX', 'XXXXXXX', #此处填写你的微信号 #'xxxx', #如果有多个用户也可以 #'xxxx', ] # 执行 icb = iciba(wechat_config) icb.run(openids)","link":"/2018/08/03/python2wx/"},{"title":"使用生成器表达式来改写数据量比较大列表推导","text":"列表推导的缺点是：在推导过程中，对于输入序列的每个值都要创建仅含一项元素的全新列表。如果数据量较大会消耗大量内存，导致程序崩溃。 推导代码：12value = [len(x) for x in open('\\file.txt')]print(value) 为了解决此问题Python提供了生成器表达式（generator expression），它是对列表推导和生成器的一种泛化(generalization)。生成器表达式在运行的时候并不会把整个输出序列都呈现出来，而是会估值为迭代器(iterator)，这个迭代器每次可以根据生成器表达式产生一项数据。 生成器表达式把实现列表推导式所用的写法放入一对圆括号中，就构成了生成器表达式。 123it = (len(x) for x in open('\\file.txt'))print(it)print(next(it)) 生成器表达式组合123it = (len(x) for x in open('\\file.txt'))roots = ((x,x**0.5) for x in it)print(next(roots)) 外围的迭代器每次前进时，都会推动内部的迭代器。 组合的表达式速度会很快 二者区别生成器表达式求值时，它会立刻返回一个迭代器，而不会深入处理文件中的内容。","link":"/2020/04/17/generator-expression/"},{"title":"Static Js Cdn","text":"前段项目日常经常会用到js框架，收集了目前国内主流的cdn服务商提供的静态JS StaticFilestaticfile是一个优秀的开源库并提供CDN服务除了静态的js文件外，staticfile还提供CSS 、图片、和swf等静态文件的CDN服务。 React vue Angular jquery都比较好用。支持http和https两种链接形式。 StaticFile SAE Public Resource渣浪的云服务提供的CDN，界面也比较渣，支持的框架比较少，好在是大牌。SAE CDN CDNJS看名字就知道这个网站是干嘛的。专业的静态js框架cdn服务提供商，提供的JS比较全。CDNJS jsDelivr国外的一家提供前段公共库的网站，只有https服务，界面比较友好。jsDeliver Upyun和Segmentfault又拍云和SegementFault提供的CDN服务。upai","link":"/2018/09/03/static-js-cdn/"},{"title":"python-analytics","text":"最近小红说要买个二手房，让我帮忙看一下二手房的信息，嗯毕竟买房是个麻烦事，而近一个月济南房价真是涨疯了。 刚好现在学python，正好可以拿来作为练手，想要实现二手房的价格数据分析。 首先想了一下基本的逻辑，先从58同城爬取一下以区域划分的房源信息。 1.首先使用Chrome调试工具分析出页面中的信息所在tag的位置，通过BeautifulSoup或正则re或lxml这三个Modules分析出信息。 由于三个Modules掌握都不熟练所以这混合了这三种模块。 通过输入可以选择不同的行政区进行数据的选择。 只有数据还不够直观，通过地理位置的抓取和高德地图的逆解析得到房源信息的坐标，然后展示到地图上。嗯 就这么干… 在匹配数据的过程中，发现会被高德(阿里)的服务器拒绝，所以加了延时500ms。 爬取得到的房源数据 你解析得到的坐标数据 放到页面上，alpha_version 可解析出房源所在位置附近的商圈。 觉得有点丑，然后又有了第二个版本2nd 在此版本中发现，如果坐标一样或者坐标太近等原因导致大量的数据没有被展现出来。然后又有了第三个版本。热点Heatmap 好吧，轮子造到这里。鉴于近期济南房价的疯狂涨势,留着数据，一个月后再爬取一下，再做个涨幅数据的分析。","link":"/2016/09/08/python-analytics/"},{"title":"python-summarization","text":"自动摘要（Automatic Summarization）的方法主要有两种：Extraction和Abstraction。其中Extraction是抽取式自动文摘方法，通过提取文档中已存在的关键词，句子形成摘要；Abstraction是生成式自动文摘方法，通过建立抽象的语意表示，使用自然语言生成技术，形成摘要。由于自动摘要方法需要复杂的自然语言理解和生成技术支持，应用领域受限。，抽取式摘要成为现阶段主流，它也能在很大程度上满足人们对摘要的需求。 目前抽取式的主要方法： 基于统计：统计词频，位置等信息，计算句子权值，再简选取权值高的句子作为文摘，特点：简单易用，但对词句的使用大多仅停留在表面信息。 基于图模型：构建拓扑结构图，对词句进行排序。例如，TextRank/LexRank 基于潜在语义：使用主题模型，挖掘词句隐藏信息。例如，采用LDA，HMM 基于线路规划：将摘要问题转为线路规划，求全局最优解。 2007年，美国学者的论文《A Survey on Automatic Text Summarization》（Dipanjan Das, Andre F.T. Martins, 2007）总结了目前的自动摘要算法。其中，很重要的一种就是词频统计。这种方法最早出自1958年的IBM公司科学家 H.P. Luhn的论文《The Automatic Creation of Literature Abstracts》。 Luhn博士认为，文章的信息都包含在句子中，有些句子包含的信息多，有些句子包含的信息少。”自动摘要”就是要找出那些包含信息最多的句子。句子的信息量用”关键词”来衡量。如果包含的关键词越多，就说明这个句子越重要。Luhn提出用”簇”（cluster）表示关键词的聚集。所谓”簇”就是包含多个关键词的句子片段。 上图就是Luhn原始论文的插图，被框起来的部分就是一个”簇”。只要关键词之间的距离小于”门槛值”，它们就被认为处于同一个簇之中。Luhn建议的门槛值是4或5。也就是说，如果两个关键词之间有5个以上的其他词，就可以把这两个关键词分在两个簇。下一步，对于每个簇，都计算它的重要性分值。 以上图为例，其中的簇一共有7个词，其中4个是关键词。因此，它的重要性分值等于 ( 4 x 4 ) / 7 = 2.3。 然后，找出包含分值最高的簇的句子（比如5句），把它们合在一起，就构成了这篇文章的自动摘要。具体实现可以参见 《Mining the Social Web: Analyzing Data from Facebook, Twitter, LinkedIn, and Other Social Media Sites》（O’Reilly, 2011）一书的第8章，python代码见github。 Luhn的这种算法后来被简化，不再区分”簇”，只考虑句子包含的关键词。下面就是一个例子（采用伪码表示），只考虑关键词首先出现的句子。 类似的算法已经被写成了工具，比如基于Java的Classifier4J库的SimpleSummariser模块、基于C语言的OTS库、以及基于classifier4J的C#实现和python实现。 参考文章： http://www.ruanyifeng.com/blog/2013/03/automatic_summarization.html http://joshbohde.com/blog/document-summarization TextTeaserTextTeaser 原本是为在线长文章（所谓 tl;dr：too long; didn’t read）自动生成摘要的服务，其原本的收费标准是每摘要 1000 篇文章付费 12 美元或每月 250 美元。巴尔宾称 TextTeaser 可以为任何使用罗马字母的文本进行摘要，而且比同类工具如 Cruxbot 和 Summly（在 2013 年 3 月被 雅虎斥资 3000 万美元收购）更准确。其创造者霍洛•巴尔宾（Jolo Balbin）表示，在“发现一些扩展问题，特别是 API 中的问题后”，他决定将 TextTeaser 代码开源。 TextTeaser开源的代码一共有三个class，TextTeaser,Parser,Summarizer。 TextTeaser，程序入口类。给定待摘要的文本和文本题目，输出文本摘要，默认是原文中最重要的5句话。 Summarizer，生成摘要类。计算出每句话的分数，并按照得分做排序，然后按照原文中句子的顺序依次输出得分最高的5句话作为摘要。 Parser，文本解析类。对文本进行去除停用词、去除标点符号、分词、统计词频等一些预处理操作。 其中打分模型分为四部分： 句子长度，长度为20的句子为最理想的长度，依照距离这个长度来打分。 句子位置，根据句子在全文中的位置，给出分数。（巴尔宾认为一篇文章的第二句比第一句更重要，因为很多作家都习惯到第二句话引入关键点）备注：用段落效果会怎样？ 文章标题与文章内容的关系，句子是否包含标题词，根据句子中包含标题词的多少来打分。 句子关键词打分，文本进行预处理之后，按照词频统计出排名前10的关键词，通过比较句子中包含关键词的情况，以及关键词分布的情况来打分（sbs，dbs两个函数）。 开源版本： Scala版本：https://github.com/MojoJolo/textteaser Python版本：https://github.com/DataTeaser/textteaser 自己尝试这个调用Python版本。主要：不要使用pip install textteaser进行安装，该安装方式安装的是这个项目： https://github.com/jgoettsch/py-textteaser，该项目并非算法实现，而是API实现。直接下载代码即可：https://github.com/DataTeaser/textteaser 下载完成后在Windows下运营test.py会报错，报错信息如下： 123456789101112 Traceback (most recent call last): File “D:/textteaser/test.py”, line 12, in sentences = tt.summarize(title, text) File “D:\\textteaser\\textteaser__init.py”, line 13, in summarize result = self.summarizer.summarize(text, title, source, category) File “D:\\textteaser\\textteaser\\summarizer.py”, line 11, in summarize sentences = self.parser.splitSentences(text) File “D:\\textteaser\\textteaser\\parser.py”, line 62, in splitSentences tokenizer = nltk.data.load(‘file:’ + os.path.dirname(os.path.abspath(file__)) + ‘/trainer/english.pickle’) File “C:\\Python27\\lib\\site-packages\\nltk\\data.py”, line 806, in load resource_val = pickle.load(opened_resource)ImportError: No module named copy_reg 针对报错信息，做如下修改： 1、将”D:\\textteaser\\textteaser\\parser.py”第62行进行修改： 12 #tokenizer = nltk.data.load(‘file:’ + os.path.dirname(os.path.abspath(file)) + ‘/trainer/english.pickle’)tokenizer = nltk.data.load(‘file:’ + os.path.dirname(os.path.abspath(file)) + os.sep + ‘trainer’ + os.sep + ‘english.pickle’) 2、找到”\\Lib\\site-packages\\nltk\\data.py”第924行，将 1 return find(path_, [‘’]).open() 修改为： 123456789 filepath = find(path, [‘’]) data = open(file_path, ‘rb’).read() newdata = data.replace(“\\r\\n”, “\\n”) if newdata != data: f = open(file_path, “wb”) f.write(newdata) f.close() f = open(file_path, “rb”) return f 注意：TextTeaser目前只支持英文摘要。 TextRankTextRank算法是一种用于文本的基于图的排序算法。其基本思想来源于谷歌的PageRank算法, 通过把文本分割成若干组成单元(单词、句子)并建立图模型, 利用投票机制对文本中的重要成分进行排序, 仅利用单篇文档本身的信息即可实现关键词提取、文摘。和 LDA、HMM 等模型不同, TextRank不需要事先对多篇文档进行学习训练, 因其简洁有效而得到广泛应用。 TextRank 一般模型可以表示为一个有向有权图 G =(V, E), 由点集合 V和边集合 E 组成, E 是V ×V的子集。图中任两点 Vi , Vj 之间边的权重为 wji , 对于一个给定的点 Vi, In(Vi) 为 指 向 该 点 的 点 集 合 , Out(Vi) 为点 Vi 指向的点集合。点 Vi 的得分定义如下: 其中, d 为阻尼系数, 取值范围为 0 到 1, 代表从图中某一特定点指向其他任意点的概率, 一般取值为 0.85。使用TextRank 算法计算图中各点的得分时, 需要给图中的点指定任意的初值, 并递归计算直到收敛, 即图中任意一点的误差率小于给定的极限值时就可以达到收敛, 一般该极限值取 0.0001。 基于TextRank的关键词提取 关键词抽取的任务就是从一段给定的文本中自动抽取出若干有意义的词语或词组。TextRank算法是利用局部词汇之间关系（共现窗口）对后续关键词进行排序，直接从文本本身抽取。其主要步骤如下： 把给定的文本T按照完整句子进行分割， 对于每个句子，进行分词和词性标注处理，并过滤掉停用词，只保留指定词性的单词，如名词、动词、形容词，其中是保留后的候选关键词。 构建候选关键词图G = (V,E)，其中V为节点集，由2生成的候选关键词组成，然后采用共现关系（co-occurrence）构造任两点之间的边，两个节点之间存在边仅当它们对应的词汇在长度为K的窗口中共现，K表示窗口大小，即最多共现K个单词。 根据上面公式，迭代传播各节点的权重，直至收敛。 对节点权重进行倒序排序，从而得到最重要的T个单词，作为候选关键词。 由5得到最重要的T个单词，在原始文本中进行标记，若形成相邻词组，则组合成多词关键词。例如，文本中有句子“Matlab code for plotting ambiguity function”，如果“Matlab”和“code”均属于候选关键词，则组合成“Matlab code”加入关键词序列。 基于TextRank的自动文摘 基于TextRank的自动文摘属于自动摘录，通过选取文本中重要度较高的句子形成文摘，其主要步骤如下： 预处理：将输入的文本或文本集的内容分割成句子得，构建图G =（V,E），其中V为句子集，对句子进行分词、去除停止词，得，其中是保留后的候选关键词。 句子相似度计算：构建图G中的边集E，基于句子间的内容覆盖率，给定两个句子，采用如下公式进行计算：)若两个句子之间的相似度大于给定的阈值，就认为这两个句子语义相关并将它们连接起来，即边的权值： 句子权重计算：根据公式，迭代传播权重计算各句子的得分； 抽取文摘句：将3得到的句子得分进行倒序排序，抽取重要度最高的T个句子作为候选文摘句。 形成文摘：根据字数或句子数要求，从候选文摘句中抽取句子组成文摘。 参考资料： https://github.com/letiantian/TextRank4ZH https://github.com/chenbjin/ASExtractor 玻森自动摘要玻森采用的是最大边缘相关模型（Maximal Marginal Relevance）的一个变种。MMR是无监督学习模型，它的提出是为了提高信息检索（Information Retrieval）系统的表现。例如搜索引擎就是目前大家最常用的信息检索系统。大家可能经常会碰到，对于我们输入的一个关键词，搜索引擎通常会给出重复的或者内容太接近的检索的情况。为了避免这个现象，搜索引擎可以通过MMR来增加内容的多样性，给出多方面考虑的检索结果，以此来提高表现。这样的思想是可以被借鉴用来做摘要的，因为它是符合摘要的基本要求的，即权衡相关性和多样性。不难理解，摘要结果与原文的相关性越高，它就接近全文中心意思。而考虑多样性则使得摘要内容更加的全面。非常的直观和简单是该模型的一个优点。 相比于其他无监督学习方法，如TextRank（TR）， PageRank（PR）等，MMR是考虑了信息的多样性来避免重复结果。TR，PR是基于图（Graph）的学习方法，每个句子看成点，每两个点之间都有一条带权重（Weighted）的无向边。边的权重隐式定义了不同句子间的游走概率。这些方法把做摘要的问题看成随机游走来找出稳态分布（Stable Distribution）下的高概率（重要）的句子集，但缺点之一便是无法避免选出来的句子相互之间的相似度极高的现象。而MMR方法可以较好地解决句子选择多样性的问题。具体地说，在MMR模型中，同时将相关性和多样性进行衡量。因此，可以方便的调节相关性和多样性的权重来满足偏向“需要相似的内容”或者偏向“需要不同方面的内容”的要求。对于相关性和多样性的具体评估，玻森是通过定义句子之间的语义相似度实现。句子相似度越高，则相关性越高而多样性越低。 自动摘要的核心便是要从原文句子中选一个句子集合，使得该集合在相关性与多样性的评测标准下，得分最高。数学表达式如下： 需要注意的是，D，Q，R，S都为句子集，其中，D表示当前文章，Q表示当前中心意思，R表示当前非摘要，S表示当前摘要。可以看出，在给定句子相似度的情况下，上述MMR的求解为一个标准的最优化问题。但是，上述无监督学习的MMR所得摘要准确性较低，因为全文的结构信息难以被建模，如段落首句应当有更高的权重等。为了提高新闻自动摘要的表现，玻森在模型中加入了全文结构特征，将MMR改为有监督学习方法。从而模型便可以通过训练从“标准摘要”中学习特征以提高准确性。 玻森采用摘要公认的Bi-gram ROUGE F1方法来判断自动生成的摘要和“标准摘要”的接近程度。经过训练，玻森在训练数集上的表现相对于未学习的摘要结果有了明显的提升——训练后的摘要系统F1提高了30%。值得一提的是，在特征训练中，为了改善摘要结果的可读性，玻森加指代关系特征，使得模型表现提高了8%。 相关链接： http://bosonnlp.com/ http://docs.bosonnlp.com/summary.html 其他相关开源项目： https://github.com/isnowfy/snownlp https://github.com/jannson/yaha https://github.com/miso-belica/sumy","link":"/2016/09/27/python-summarization/"},{"title":"Raspberry Os","text":"常用树莓派系统","link":"/2018/11/22/raspberry-os/"},{"title":"python-map-reduce","text":"在Python里内建了Map和Reduce 函数，一开始怎么也看不明白，看图识也不明白。 直到看了”MapReduce:Simplified Data Processing on Large Clusters” link（面向大型集群的简化数据处理）这个论文来自GOOGLE.Map(映射)Reduce(化简)MapRedce 既是一种编程模型，也是一种与之关联的、用于处理和产生大数据集的实现。用户要特化一个map程序去处理key/value对，并产生中间key/value对的集合，以及一个Reduce程序去合并有着相同key的所有中间key/value对。 用这种函数风格写出的程序自动就拥有了在一个大的PC机集群上并执行的能力。运行时系统会负责细节：切分输入数据，在一组机器上调度执行程序，处理机器错误，以及管理所需的机器间通信。这允许不具备任何并行和分布式系统经验的程序员也能轻松地利用一个大型分布式系统的资源。我们的MapReduce实现运行在一个大型PC机集群上，且具有很好的扩展性：一个典型的MapReduce作业运行在Google的集群上。编程模型计算过程就是输入一组key/value对，再生成一组key/value对。MapReduce库的使用者用两个函数来表示这个过程：map和reduce。 map由使用者编写,使用一个输入key/value对，生成一组中间key/value对。MapReduce库将有着相同中间Key I中间的value都组合在一起，再传给reduce函数。reduce也由使用者编写，它接受一个中间Key I 和一组与I对应的value.他将这些value合并为一个可能更小的value集合。通常每个reduce调用只产生0或1输出value.中间value是通过一个迭代器提供给reduce函数的。这允许我们操作那些因为大到找不到连续存放的内存而使用链表的value集合。 Example: 123456789101112key,String value): //key:文档名 //value：文档内容 for each word w in value: EmitIntermediate(w,\"1\");reduce(Stringkey,Iterator values): //key:一个单词 //value:计数值列表 int result = 0; for each v in values: result += ParseInt(v); Emit(AsString(result)); map函数将每个单词与出现次数一同输出（↑例子中鸡蛋的那输出“1”）reduce函数将针对某个特定词输出的次数都合并相加。 另外，使用者要写代码填充一个符合MapReduce规格的对象，内容包括输入和输出文件的名字，以及可选的调节参数。之后使用者调用MapReduce函数，将指定到对象传进去。用户代码会与MapReduce库链接到一起。 实现许多不同的MapReduce的实现都是可行的。选择哪一个要取决于环境。例如，一种实现可能适合于小型的共享内存机器，一种实现可能适合于大型的NUMA多处理器机器，而另一种则适合于更大型的联网机器集。 本部分描述的实现主要面向Google内部广泛使用的计算环境：大型的商用PC机集群，互相之间用交换式以太网连接。我们的环境是： 主要使用的机器为双核X86处理器，运行Linux系统，每台机器的内存从2GB到4GB不等。 使用的都是商用网络硬件设备——在机器层面上通常从100Mbps到1Gbps不等，但平均起来要比总带宽的一半少很多。 集群中拥有数百或数千台机器，因此机器错误经常出现。 每台机器都使用廉价的IDE硬盘来提供存储功能。我们使用一种内部开发的分布式文件系统来管理这些磁盘上的数据。这个文件系统通过复制的方法在不可靠的硬件之上提供了实用性与可靠性。 用户向一个调度系统提交作业。每个作业包括了一个任务集，会由调度器调度到集群内可用的一组机器上。","link":"/2016/09/26/python-map-reduce/"},{"title":"Windows Collections","text":"##windows 10 license licenseWin10专业版 7M2H3-J3VPB-2X2DK-33CC2-CHPH4 ​Win10 企业版：XCBWP-GN2BX-QJDYV-XQV7K-C7JWR Win10专业版：V942D-C7NFG-773PY-MT398-F3KTY Collection up to spare","link":"/2018/11/22/windows-collections/"},{"title":"Baidu wenku","text":"日常无论是工作还是生活都可能需要用到百毒文库好多都是需要花钱的， 或者你没有下载券，今天分享一个工具，也为自己做个Mark。 工具网址：http://www.1234866.com/ 只能下载 使用下载券下载的文档。","link":"/2018/08/17/wenku/"},{"title":"利器收集","text":"收集了经常用到的工具，为了年纪大了不太好的记忆。 typoraTypora markdown转换为html,pdfMd2All 将代码片段生成图片codezencarbon 变量命名类名函数名变量名不知道如何起名才好，可以用这个工具。unbug Screenzy beautify your screenshots!screenzy 🍦 to be continue","link":"/2020/02/11/tool-colloections/"},{"title":"Science and the Internet","text":"普及一下科学冲浪技巧 普及一下ssr基本原理是在歪果仁哪里租一台服务器，然后在服务器上搭建一个反向代理的服务，歪果仁的服务器访问歪果仁的站点肯定是so爽so快soEasy。 使用方式，打开app然后去找可用的节点，ssr：或者ss：开头的一串乱码》》》 或者是使用软件扫描节点的二维码，直接输入节点信息也可以。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img src=”https://i.loli.net/2018/08/10/5b6d69daea50a.png&quot; height=”10px” \bwidth=”10px” &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mac &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS &nbsp;&nbsp;&nbsp;&nbsp;Android windows Mac 联系我下载 Android 请低调传播","link":"/2018/08/07/universets/"},{"title":"ubuntu-lts","text":"前几天心血来潮看到都在说 Elementary 这个Ubuntu的分支是最美的。于是趁着有点闲空，就做了个启动盘，Elementary可以正确识别之前安装的Ubuntu，然后就执行了覆盖安装。 Elementary确实有着独到的美感，有点像MAC的感觉，但是很多的软件都是非常的不常见，有点差异化发展的意思。但是并没有Ubuntu好用，遂决定再回到Ubuntu的环境。 说起Ubuntu，这要追溯到2008年，当时Ubuntu为了推广，在网上发布了免费申请Ubuntu的安装光盘的活动，立马就申请了（32bit和64bit各一份），暑假之前申请，历经2个多月的大学暑假，大概是开学一个多月后，收到学校邮局的通知，当时因为地址填写的是英文，据邮局的工作人员说有三四个老师轮番翻译了一边才正确投递。 拿到手的第一时间就感觉好兴奋，当时就被Ubuntu的人文情感所迷倒，人生的第一份来自地球另一端的快件。还附赠了logo贴纸，至今我都留着没舍得乱贴。封面设计非常简单，四个来自不同国家的年轻人躺在草地上，就这样的简单意境，对我对IT的认知产生了新的影响。 Canonical 在今年的4月发布了16.04 LTS（Xenial Xerus）发布说这是一个长期支持版本，官方会提供长达5年的Techinical Support，也就是大概可以支持到2021年4月左右，这也是决定要重新安装回到Ubuntu的一个原因。 附上下载地址：Ubuntu 16.04 LTS官方镜像下载： 32位：http://releases.ubuntu.com/16.04/ubuntu-16.04-desktop-i386.iso 64位：http://releases.ubuntu.com/16.04/ubuntu-16.04-desktop-amd64.iso 1关于如何安装就不在这里赘述了，网上可以GG到一大片，恩想要GG的可以看Google Mirror这篇文章。 关于SUBLIME TEXT3的中文输入问题 123因为安装这个Linux主要是为了Python的开发环境，所以围绕着Python做了环境部署。编辑及IDE环境使用 Pycharm VIM Gedit atom Sublime Text3其中，在SublimeText3 解决无法使用中文的问题，网上的答案几乎出自同一个人，但是并不好用，需要生成共用的配置文件等。其实在github上有个更为简单的解决方法。 github/lyfeyaj 12345678910Step to use this repo1.Update and then upgrade your system to the newest`sudo apt-get updat &amp;&amp; sudo apt-get updrade`2.Clone this repo in your local directory:`git clone https://github.com/lyfeyaj/sublime-text-imfix.git`3.Change your current directory to sublime-text-imfix:`cd sublime-text-imfix`4.Run the below script:`./sublim-imfix`5.Done! Re-login Ubuntu.And then you gan enjoy using Sublime Text3! 关于有道词典的安装. 1有道词典提供Linux的deb安装包，但是下载了Ubuntu 64bit的安装包无法正常安装，使用install -f解决依赖包的问题也无法正常解决，看到页面置顶的是Deepin的deb包尝试了一下 下载后直接一步安装成功～ 关于Pycharm 12现在来看使用Pycharm的人越来越多，而且Pycharm也相对智能人性一些，在创建Project的时候提供选择语言环境，是Python2还是Python3，有点类似使用Python自己的虚拟环境的感觉。注意 2016版本使用网上的 Lisence server已经失效，不过还是侥幸找到一枚可用的激活码。 Ubuntu install Ubuntu下的多线程下载工具Uget和aria2下载神器，类似win下的迅雷 旋风等工具 Install1.添加依赖sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo add-apt-repository ppa:t-tujikawa/ppa2.更新依赖sudo apt-get update3.安装uget 、aria2sudo apt-get install uget aria24.配置将最大连接数设置为16uget—All Category—右键—Properties—Default for new download1—Max Connections—16开启aria插件uget—右键—settings—Plug-in—Plug-in matching order—aria2同时，下方的arguments: –enable-rpc=true","link":"/2015/09/25/ubuntu-lts/"}],"tags":[{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"collect","slug":"collect","link":"/tags/collect/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"MatPlotlib","slug":"MatPlotlib","link":"/tags/MatPlotlib/"},{"name":"ebook,kindle,collect","slug":"ebook-kindle-collect","link":"/tags/ebook-kindle-collect/"},{"name":"Jieba","slug":"Jieba","link":"/tags/Jieba/"},{"name":"BeautifulSoup","slug":"BeautifulSoup","link":"/tags/BeautifulSoup/"},{"name":"DNS","slug":"DNS","link":"/tags/DNS/"},{"name":"micropython,esp8266,Oled,collect","slug":"micropython-esp8266-Oled-collect","link":"/tags/micropython-esp8266-Oled-collect/"},{"name":"markdown,fontawesome,collect","slug":"markdown-fontawesome-collect","link":"/tags/markdown-fontawesome-collect/"},{"name":"podcast,study,collect","slug":"podcast-study-collect","link":"/tags/podcast-study-collect/"},{"name":"python,wechat,collect","slug":"python-wechat-collect","link":"/tags/python-wechat-collect/"},{"name":"javascript,study,collect","slug":"javascript-study-collect","link":"/tags/javascript-study-collect/"},{"name":"python,raspberry,collect","slug":"python-raspberry-collect","link":"/tags/python-raspberry-collect/"},{"name":"windows,license,collect","slug":"windows-license-collect","link":"/tags/windows-license-collect/"},{"name":"baidu,data,collect","slug":"baidu-data-collect","link":"/tags/baidu-data-collect/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"ssr,shadow,collect","slug":"ssr-shadow-collect","link":"/tags/ssr-shadow-collect/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"install","slug":"install","link":"/tags/install/"}],"categories":[{"name":"docs","slug":"docs","link":"/categories/docs/"},{"name":"python","slug":"docs/python","link":"/categories/docs/python/"},{"name":"Android","slug":"docs/Android","link":"/categories/docs/Android/"},{"name":"index","slug":"docs/index","link":"/categories/docs/index/"},{"name":"ebook","slug":"ebook","link":"/categories/ebook/"},{"name":"index","slug":"docs/python/index","link":"/categories/docs/python/index/"},{"name":"collections","slug":"docs/collections","link":"/categories/docs/collections/"},{"name":"index","slug":"docs/Android/index","link":"/categories/docs/Android/index/"},{"name":"micropython","slug":"micropython","link":"/categories/micropython/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"podcast","slug":"docs/podcast","link":"/categories/docs/podcast/"},{"name":"index","slug":"ebook/index","link":"/categories/ebook/index/"},{"name":"javascript","slug":"docs/javascript","link":"/categories/docs/javascript/"},{"name":"raspberry","slug":"docs/raspberry","link":"/categories/docs/raspberry/"},{"name":"license","slug":"license","link":"/categories/license/"},{"name":"baidu","slug":"baidu","link":"/categories/baidu/"},{"name":"Tools","slug":"docs/index/Tools","link":"/categories/docs/index/Tools/"},{"name":"ssr","slug":"ssr","link":"/categories/ssr/"},{"name":"system","slug":"docs/system","link":"/categories/docs/system/"},{"name":"Raspberry","slug":"docs/python/index/Raspberry","link":"/categories/docs/python/index/Raspberry/"},{"name":"index","slug":"docs/collections/index","link":"/categories/docs/collections/index/"},{"name":"index","slug":"micropython/index","link":"/categories/micropython/index/"},{"name":"index","slug":"markdown/index","link":"/categories/markdown/index/"},{"name":"index","slug":"docs/podcast/index","link":"/categories/docs/podcast/index/"},{"name":"index","slug":"docs/javascript/index","link":"/categories/docs/javascript/index/"},{"name":"index","slug":"docs/raspberry/index","link":"/categories/docs/raspberry/index/"},{"name":"windows","slug":"license/windows","link":"/categories/license/windows/"},{"name":"index","slug":"baidu/index","link":"/categories/baidu/index/"},{"name":"python","slug":"ssr/python","link":"/categories/ssr/python/"},{"name":"index","slug":"docs/system/index","link":"/categories/docs/system/index/"},{"name":"Cloudflare","slug":"docs/python/index/Raspberry/Cloudflare","link":"/categories/docs/python/index/Raspberry/Cloudflare/"},{"name":"index","slug":"license/windows/index","link":"/categories/license/windows/index/"},{"name":"index","slug":"ssr/python/index","link":"/categories/ssr/python/index/"}]}