{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"2019书单计划","text":"转眼间2019已经过去快一半的时间了，想到年初立的flag 虽然在做却没有及时的总结和复盘。今天把今年需要读的书单发出来，以提醒自己。 月亮与六便士 刻意练习 动物农场 时间管理 微习惯 微精通 极简工作法 技术类精通Scrapy网络爬虫 精通Python爬虫框架Scrapy 编程珠玑 编写可维护的JavaScript Python编程无师自通 MicroPython for the Internet of Things 图解HTTP 其他极客物理学 理财类穷查理宝典 语言类1368个单词就够了 另外还有eslpod 和englipod的音频 反复练习读听写 todo list 精通Scrapy网络爬虫 圣斗士星矢 万历十五年 动物农场（中文） 日语五十音图详解","link":"/2019/04/24/booklist/"},{"title":"Python-ticks","text":"整理和维护经常慧用到的python技巧 Upack 当需要从某个可迭代对象中分决出N个元素，但是这个可迭代对象的长度可能超过N，这会导致“分解的值过多（too many values to unpack）”的异常 解决方案 使用python的“*表达式”可以解决这个问题。 123def drop_first_last(grades): first,*middle,last = grades return avg(middle) 在分解任意长度的可迭代对象时特别好用 1234567891011121314records =[ ('foo',1,3), ('bar','hello'), ('foo',3,4),]def do_foo(x,y): print('foo',x,y)def do_bar(s): print('bar',s)for tag,*args in records: if tag=='foo': do_foo(*args) elif tag=='bar': do_bar(*args) 步进切片从列表中创建一定间隔的新列表 1234567&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a[::2][0, 2, 4, 6, 8, 10]&gt;&gt;&gt; a[::3][0, 3, 6, 9]&gt;&gt;&gt; a[2:8:2][2, 4, 6] list slice with step (a[start:end:step]) 生成倒叙的list 12345&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; a[::-1][10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]&gt;&gt;&gt; a[::-2][10, 8, 6, 4, 2, 0] 命名切片的调用Naming slices (slice(start,end,step)) 123456&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5]&gt;&gt;&gt; LASTTHREE = slice(-3, None)&gt;&gt;&gt; LASTTHREEslice(-3, None, None)&gt;&gt;&gt; a[LASTTHREE][3, 4, 5] 遍历列表的索引和值Iterating over list index and value pairs (enumerate) 1234567&gt;&gt;&gt; a = ['Hello', 'world', '!']&gt;&gt;&gt; for i, x in enumerate(a):... print '{}: {}'.format(i, x)...0: Hello1: world2: ! 遍历字典dict.iteritems 12345678&gt;&gt;&gt; m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}&gt;&gt;&gt; for k, v in m.iteritems():... print '{}: {}'.format(k, v)...a: 1c: 3b: 2d: 4 压缩和解压缩列表Zipping and unzipping lists 1234567&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = ['a', 'b', 'c']&gt;&gt;&gt; z = zip(a, b)&gt;&gt;&gt; z[(1, 'a'), (2, 'b'), (3, 'c')]&gt;&gt;&gt; zip(*z)[(1, 2, 3), ('a', 'b', 'c')] 使用zip分组相邻的列表项Grouping adjacent list items using zip 1234567891011121314151617181920&gt;&gt;&gt; # Using iterators&gt;&gt;&gt; group_adjacent = lambda a, k: zip(*([iter(a)] * k))&gt;&gt;&gt; group_adjacent(a, 3)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent(a, 2)[(1, 2), (3, 4), (5, 6)]&gt;&gt;&gt; group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)]&gt;&gt;&gt; # Using slices&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; group_adjacent = lambda a, k: zip(*(islice(a, i, None, k) for i in range(k)))&gt;&gt;&gt; group_adjacent(a, 3)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent(a, 2)[(1, 2), (3, 4), (5, 6)]&gt;&gt;&gt; group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)] 使用滑动窗口迭代器Sliding windows (nn -grams) using zip and iterators 123456789101112&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; def n_grams(a, n):... z = (islice(a, i, None) for i in range(n))... return zip(*z)...&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; n_grams(a, 3)[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]&gt;&gt;&gt; n_grams(a, 2)[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]&gt;&gt;&gt; n_grams(a, 4)[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)] 字典的键值反转Inverting a dictionary using zip 12345678&gt;&gt;&gt; m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}&gt;&gt;&gt; m.items()[('a', 1), ('c', 3), ('b', 2), ('d', 4)]&gt;&gt;&gt; zip(m.values(), m.keys())[(1, 'a'), (3, 'c'), (2, 'b'), (4, 'd')]&gt;&gt;&gt; mi = dict(zip(m.values(), m.keys()))&gt;&gt;&gt; mi{1: 'a', 2: 'b', 3: 'c', 4: 'd'} 展开列表Flattening lists 1234567891011121314&gt;&gt;&gt; a = [[1, 2], [3, 4], [5, 6]]&gt;&gt;&gt; list(itertools.chain.from_iterable(a))[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; sum(a, [])[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; [x for l in a for x in l][1, 2, 3, 4, 5, 6]&gt;&gt;&gt; a = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]&gt;&gt;&gt; [x for l1 in a for l2 in l1 for x in l2][1, 2, 3, 4, 5, 6, 7, 8]&gt;&gt;&gt; a = [1, 2, [3, 4], [[5, 6], [7, 8]]]&gt;&gt;&gt; flatten = lambda x: [y for l in x for y in flatten(l)] if type(x) is list else [x]&gt;&gt;&gt; flatten(a)[1, 2, 3, 4, 5, 6, 7, 8] 生成器表达式Generator expressions 12345678910111213&gt;&gt;&gt; g = (x ** 2 for x in xrange(10))&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; sum(x ** 3 for x in xrange(10))2025&gt;&gt;&gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)408 字典推导式Dicitonary comprehensions 123456&gt;&gt;&gt; m = {x: x ** 2 for x in range(5)}&gt;&gt;&gt; m{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}&gt;&gt;&gt; m = {x: 'A' + str(x) for x in range(10)}&gt;&gt;&gt; m{0: 'A0', 1: 'A1', 2: 'A2', 3: 'A3', 4: 'A4', 5: 'A5', 6: 'A6', 7: 'A7', 8: 'A8', 9: 'A9'} 使用字典推到式反转字典Inverting a dictionary using a dictionary comprehension 12345&gt;&gt;&gt; m = {'a': 1, 'b': 2, 'c': 3, 'd': 4}&gt;&gt;&gt; m{'d': 4, 'a': 1, 'b': 2, 'c': 3}&gt;&gt;&gt; {v: k for k, v in m.items()}{1: 'a', 2: 'b', 3: 'c', 4: 'd'} 命名元组的调用Named tuples (collections.namedtuple) 12345678&gt;&gt;&gt; Point = collections.namedtuple('Point', ['x', 'y'])&gt;&gt;&gt; p = Point(x=1.0, y=2.0)&gt;&gt;&gt; pPoint(x=1.0, y=2.0)&gt;&gt;&gt; p.x1.0&gt;&gt;&gt; p.y2.0 从命名元组继承inheriting from named tuples 12345678&gt;&gt;&gt; class Point(collections.namedtuple('PointBase', ['x', 'y'])):... __slots__ = ()... def __add__(self, other):... return Point(x=self.x + other.x, y=self.y + other.y)&gt;&gt;&gt; p = Point(x=1.0, y=2.0)&gt;&gt;&gt; q = Point(x=2.0, y=3.0)&gt;&gt;&gt; p + qPoint(x=3.0, y=5.0) 集合的使用sets and set operations 123456789101112131415161718&gt;&gt;&gt; A = {1, 2, 3, 3}&gt;&gt;&gt; Aset([1, 2, 3])&gt;&gt;&gt; B = {3, 4, 5, 6, 7}&gt;&gt;&gt; Bset([3, 4, 5, 6, 7])&gt;&gt;&gt; A | Bset([1, 2, 3, 4, 5, 6, 7])&gt;&gt;&gt; A &amp; Bset([3])&gt;&gt;&gt; A - Bset([1, 2])&gt;&gt;&gt; B - Aset([4, 5, 6, 7])&gt;&gt;&gt; A ^ Bset([1, 2, 4, 5, 6, 7])&gt;&gt;&gt; (A ^ B) == ((A - B) | (B - A))True 集合的操作 12345678910111213141516&gt;&gt;&gt; A = collections.Counter([1, 2, 2])&gt;&gt;&gt; B = collections.Counter([2, 2, 3])&gt;&gt;&gt; ACounter({2: 2, 1: 1})&gt;&gt;&gt; BCounter({2: 2, 3: 1})&gt;&gt;&gt; A | BCounter({2: 2, 1: 1, 3: 1})&gt;&gt;&gt; A &amp; BCounter({2: 2})&gt;&gt;&gt; A + BCounter({2: 4, 1: 1, 3: 1})&gt;&gt;&gt; A - BCounter({1: 1})&gt;&gt;&gt; B - ACounter({3: 1}) 可迭代对象的计数 1234567&gt;&gt;&gt; A = collections.Counter([1, 1, 2, 2, 3, 3, 3, 3, 4, 5, 6, 7])&gt;&gt;&gt; ACounter({3: 4, 1: 2, 2: 2, 4: 1, 5: 1, 6: 1, 7: 1})&gt;&gt;&gt; A.most_common(1)[(3, 4)]&gt;&gt;&gt; A.most_common(3)[(3, 4), (1, 2), (2, 2)] 双端队列double-ended queue 12345678910111213141516171819&gt;&gt;&gt; Q = collections.deque()&gt;&gt;&gt; Q.append(1)&gt;&gt;&gt; Q.appendleft(2)&gt;&gt;&gt; Q.extend([3, 4])&gt;&gt;&gt; Q.extendleft([5, 6])&gt;&gt;&gt; Qdeque([6, 5, 2, 1, 3, 4])&gt;&gt;&gt; Q.pop()4&gt;&gt;&gt; Q.popleft()6&gt;&gt;&gt; Qdeque([5, 2, 1, 3])&gt;&gt;&gt; Q.rotate(3)&gt;&gt;&gt; Qdeque([2, 1, 3, 5])&gt;&gt;&gt; Q.rotate(-3)&gt;&gt;&gt; Qdeque([5, 2, 1, 3]) 最大长度双端队列double-ended queue with maximum length 123456789101112131415&gt;&gt;&gt; last_three = collections.deque(maxlen=3)&gt;&gt;&gt; for i in xrange(10):... last_three.append(i)... print ', '.join(str(x) for x in last_three)...00, 10, 1, 21, 2, 32, 3, 43, 4, 54, 5, 65, 6, 76, 7, 87, 8, 9 有序字典ordered dictionaries 123456789&gt;&gt;&gt; m = dict((str(x), x) for x in range(10))&gt;&gt;&gt; print ', '.join(m.keys())1, 0, 3, 2, 5, 4, 7, 6, 9, 8&gt;&gt;&gt; m = collections.OrderedDict((str(x), x) for x in range(10))&gt;&gt;&gt; print ', '.join(m.keys())0, 1, 2, 3, 4, 5, 6, 7, 8, 9&gt;&gt;&gt; m = collections.OrderedDict((str(x), x) for x in range(10, 0, -1))&gt;&gt;&gt; print ', '.join(m.keys())10, 9, 8, 7, 6, 5, 4, 3, 2, 1 将对象映射到唯一的计数数字mapping objects to unique counting numbers 123456789101112&gt;&gt;&gt; import itertools, collections&gt;&gt;&gt; value_to_numeric_map = collections.defaultdict(itertools.count().next)&gt;&gt;&gt; value_to_numeric_map['a']0&gt;&gt;&gt; value_to_numeric_map['b']1&gt;&gt;&gt; value_to_numeric_map['c']2&gt;&gt;&gt; value_to_numeric_map['a']0&gt;&gt;&gt; value_to_numeric_map['b']1 最大和最小元素largest and smallest elements(heapq.nlargest and heapq.nsmallest) 12345&gt;&gt;&gt; a = [random.randint(0, 100) for __ in xrange(100)]&gt;&gt;&gt; heapq.nsmallest(5, a)[3, 3, 5, 6, 8]&gt;&gt;&gt; heapq.nlargest(5, a)[100, 100, 99, 98, 98] 笛卡尔积cartesian products 1234567891011121314151617181920212223242526&gt;&gt;&gt; for p in itertools.product([1, 2, 3], [4, 5]):(1, 4)(1, 5)(2, 4)(2, 5)(3, 4)(3, 5)&gt;&gt;&gt; for p in itertools.product([0, 1], repeat=4):... print ''.join(str(x) for x in p)...0000000100100011010001010110011110001001101010111100110111101111 组合和替换组合combinations and combinations with replacemnet 12345678910111213141516171819202122&gt;&gt;&gt; for c in itertools.combinations([1, 2, 3, 4, 5], 3):... print ''.join(str(x) for x in c)...123124125134135145234235245345&gt;&gt;&gt; for c in itertools.combinations_with_replacement([1, 2, 3], 2):... print ''.join(str(x) for x in c)...111213222333 排列交换Permurtations 123456789101112131415161718192021222324252627&gt;&gt;&gt; for p in itertools.permutations([1, 2, 3, 4]):... print ''.join(str(x) for x in p)...123412431324134214231432213421432314234124132431312431423214324134123421412341324213423143124321 链式迭代chaining iterables 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; a = [1, 2, 3, 4]&gt;&gt;&gt; for p in itertools.chain(itertools.combinations(a, 2), itertools.combinations(a, 3)):... print p...(1, 2)(1, 3)(1, 4)(2, 3)(2, 4)(3, 4)(1, 2, 3)(1, 2, 4)(1, 3, 4)(2, 3, 4)&gt;&gt;&gt; for subset in itertools.chain.from_iterable(itertools.combinations(a, n) for n in range(len(a) + 1))... print subset...()(1,)(2,)(3,)(4,)(1, 2)(1, 3)(1, 4)(2, 3)(2, 4)(3, 4)(1, 2, 3)(1, 2, 4)(1, 3, 4)(2, 3, 4)(1, 2, 3, 4) 按给定键进行分组grouping rows by a given key 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&gt;&gt;&gt; from operator import itemgetter&gt;&gt;&gt; import itertools&gt;&gt;&gt; with open('contactlenses.csv', 'r') as infile:... data = [line.strip().split(',') for line in infile]...&gt;&gt;&gt; data = data[1:]&gt;&gt;&gt; def print_data(rows):... print '\\n'.join('\\t'.join('{: &lt;16}'.format(s) for s in row) for row in rows)...&gt;&gt;&gt; print_data(data)young myope no reduced noneyoung myope no normal softyoung myope yes reduced noneyoung myope yes normal hardyoung hypermetrope no reduced noneyoung hypermetrope no normal softyoung hypermetrope yes reduced noneyoung hypermetrope yes normal hardpre-presbyopic myope no reduced nonepre-presbyopic myope no normal softpre-presbyopic myope yes reduced nonepre-presbyopic myope yes normal hardpre-presbyopic hypermetrope no reduced nonepre-presbyopic hypermetrope no normal softpre-presbyopic hypermetrope yes reduced nonepre-presbyopic hypermetrope yes normal nonepresbyopic myope no reduced nonepresbyopic myope no normal nonepresbyopic myope yes reduced nonepresbyopic myope yes normal hardpresbyopic hypermetrope no reduced nonepresbyopic hypermetrope no normal softpresbyopic hypermetrope yes reduced nonepresbyopic hypermetrope yes normal none&gt;&gt;&gt; data.sort(key=itemgetter(-1))&gt;&gt;&gt; for value, group in itertools.groupby(data, lambda r: r[-1]):... print '-----------'... print 'Group: ' + value... print_data(group)...-----------Group: hardyoung myope yes normal hardyoung hypermetrope yes normal hardpre-presbyopic myope yes normal hardpresbyopic myope yes normal hard-----------Group: noneyoung myope no reduced noneyoung myope yes reduced noneyoung hypermetrope no reduced noneyoung hypermetrope yes reduced nonepre-presbyopic myope no reduced nonepre-presbyopic myope yes reduced nonepre-presbyopic hypermetrope no reduced nonepre-presbyopic hypermetrope yes reduced nonepre-presbyopic hypermetrope yes normal nonepresbyopic myope no reduced nonepresbyopic myope no normal nonepresbyopic myope yes reduced nonepresbyopic hypermetrope no reduced nonepresbyopic hypermetrope yes reduced nonepresbyopic hypermetrope yes normal none-----------Group: softyoung myope no normal softyoung hypermetrope no normal softpre-presbyopic myope no normal softpre-presbyopic hypermetrope no normal softpresbyopic hypermetrope no normal soft 在任意目录中启动http服务器 start a static http server in any directory 1python -m SimpleHTTPServer 5000","link":"/2019/12/25/decomposing-elements-from-iteratable-objects-md/"},{"title":"金庸武侠小说大全-电子版下载","text":"飞雪连天射白鹿，笑书神侠倚碧鸳，感谢查老带来的经典武侠作品，虽然没有读过几本，在大家读金庸的时候相同的时间我给了韩寒、苏童、王小波、路遥还有一系列的《电脑报》、《萌芽》、《Hacker X档案》 《黑客防线》等书籍，以下为整理的金庸武侠大全电子版，供大家下载： 《飞狐外传》 《雪山飞狐》 《连城诀》 《天龙八部》 《射雕英雄传》 《白马啸西风》 《鹿鼎记》 《笑傲江湖》 《书剑恩仇录》 《神雕侠侣》 《侠客行》 《倚天屠龙记》 《碧血剑》 《鸳鸯刀》 《越女剑》 电子书说明 TXT版本 txt版本下载 插图版 插图版下载 PDF三联 PDF版下载","link":"/2018/11/05/hero-novel/"},{"title":"0.96 OLED Display","text":"之前买过一个0.96英寸的OLED屏幕，一直没有用，最近想着做个小的玩具，比如放在桌面上的小摆件可以提醒生词，提醒todo-list等，或者结合esp8266做成一个情侣见互相留言的小玩具。 ##关于OLED OLED，即有机发光二极管( OrganicLightEmittingDiode)。 OLED 由于同时具备自发光，不需背 光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及 制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。LCD 都需要背光，而 OLED 不需要，因为它是自发光的。这样同样的显示 OLED 效果要来得好一些。 说说踩过的坑1.因为使用Micropython，可以参考的资料非常少。 2.这个OLED本身不带字库，除了英文和标准绘图（点、线、形状）之外都需要使用其他方式实现。 3.依赖SSD1306驱动，不能像Arduino的u8g2库一样强大，许多功能需要自己实现。 ##中文文字转字模型所有显示的中文都需要转换成字模，其实在购买屏幕的时候随机送了一个中文取字模的软件。PCtoLCD2002，但是我用的是Mac，总不能为了这个字模装个虚拟机吧，虽然我将另外一台win10开启了远程桌面，但是也不便于形成Demo后别人使用，在有网环境下可以用我写的一个小脚本fontool.可以方便的将想要显示的中文转换为字模。 ##图片显示关于图片的显示，网上有两种方案（基于Arduino）一种是将图片转换为二进制bin文件，另一种和中文差不多，将图片的像素转换为01二进制，0为不现实1为亮。没有现成的库。 ###实现图片的显示以我的头像这个dogydog为例。这里需要用的的python库 PIL （Pillow） 1.首先将图片处理为灰度模式，然后改变图像的大小，这里有个坑，其实你直接使用PIL的resize就好但是网上的多处例子谈到img = img.resize((w,h),Image.ANTIALIAS) 这个地方的Image.ANTIALIAS其实是用来处理大型图片缩放时候用到的一个滤镜，对比PS的文件处理速度会快一些而且质量会好一些，在应用与低质量的显示比如这块128 * 64的屏幕上完全用不到精细化处理，而且会适得其反，因为8266的内存有限，使用滤镜生成的bin文件会很大，而且在128*64这样的屏幕上会有毛刺。 对比效果 2.然后逐行的读取每个像素点的数值，生成10矩阵。代码在这里 显示效果","link":"/2019/02/26/oled-display/"},{"title":"Markdown Awesome","text":"` ` 在markdown文章张使用图标装饰在之前的工作中制作原型，包括上一篇文章中用到的iconfont的图标，每次都要处理多次。看到bootstrap的教程中使用@face-font 可以使用图标，突然想到markdown能否直接调用iconfont、fontawesome的图标？网上一搜果然是有的，像我一样的懒人在我之前就存在。 准备工作Font Awesome是一个字体和图标工具包，包含人物、动物、建筑、商业、品牌、娱乐、动作等等各种主题丰富的图标符号，iconfont也类似起步晚一点是ali旗下的一个开源工具包。 要在markdown文档中输入Font Awesome，需要在文档任意位置输入一下代码调用JavaScript。 12345&lt;head&gt; &lt;script defer src=\"https://use.fontawesome.com/releases/v5.0.13/js/all.js\"&gt;&lt;/script&gt; &lt;script defer src=\"https://use.fontawesome.com/releases/v5.0.13/js/v4-shims.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;link rel=\"stylesheet\" href=\"https://use.fontawesome.com/releases/v5.2.0/css/all.css\" integrity=\"sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ\" crossorigin=\"anonymous\"&gt; iconFont的使用方法类似，但是区别是，需要将使用的图标先用自己的账号登陆后，收藏然后下载生成的css文件。需要引用本地的css文件。当然灵活性要差一点，必须之前没有收藏某个图标，这下抓瞎了吧。😭生成的css文件格式格式类似如下： //at.alicdn.com/t/font_8d5l8fzk5b87iudi.css 使用方法现在就可以直接插入Font Awesome和iconfont的符号了。 1&lt;i class=\"fa fa-weixin\"&gt;&lt;i&gt; iconfont使用方法类似 1&lt;i class=\"iconfont icon-xxx\"&gt;&lt;/i&gt; 这是表示插入了一个微信图标的符号。 获取符号名称fa-weixin 是微信的\b名称，如何\b调用其他的\b图标呢？在\bawesome 获取后可以保存到LaunchBar中一遍以后方便使用。iconfont 只需要点击收藏就好，在生成的css中可以查询。 调节尺寸1&lt;i class=\"fa fa-weixin\"&gt;&lt;i&gt; 扩展改写为： 1&lt;i class=\"fa fa-weixin fa-2x\"&gt;&lt;i&gt; 可用参数列表：123456fa-xsfa-smfa-lgfa-2x至fa-10x\b### 动画效果\b在class中加入 “fa-spin” 使符号变成连贯转动，加入“fa-pulse”变成8步\b旋转效果。 符号的特殊用法####符号下沉 1234&lt;i class=\"fas fa-quote-left fa-3x fa-pull-left\"&gt;&lt;/i&gt;fa-quote-left 是符号名称fa-3x 表示大小fa-pull-left 符号下沉 上篇文章中所应用到的图标 应该如下正确使用: 小火箭 以上是\bicon的应用，接下来制定自己的学习计划，开始学习Vue.js。","link":"/2018/08/17/markdown-awesome/"},{"title":"及时行乐","text":"及时行乐（Enjoy Pleasure in Good Time.） 人生苦短,何不及时行乐释义：抓紧时机，不失时机，寻欢作乐。 出处:《新刊大宋宣和遗事》：“人生如白驹过隙，倘不及时行乐，则老大徒伤悲也。”例句：短歌行（曹操）对酒当歌，人生几何？ 譬如朝露，去日苦多。 慨当以慷，忧思难忘。 何以解忧？唯有杜康。 So, there you have it… enjoy!","link":"/2018/08/03/about/"},{"title":"Python 推送信息到wechat","text":"前言最近看到网上有定时推送文章到微信的文章，其实这个小功能我一直在做，包括定时爬取内容用邮件发送等等。不过网上都是python2.7的版本。对于使用python3的小白可能用起来比较困惑，手动改了一个python3的版本。 #实现环境 python3.6(conda) 数据源：爱词霸 调用地址：http://open.iciba.com/dsapi/ 请求方式：GET 请求参数： 参数 必选 类型 说明 \bdate 否 string 格式为：2018-08-01；默认取当天 type 否 string 可选值为last和next；以date日期为准的last返回前一天，next返回后一天。 代码示例 123456789#coding=utf-8import jsonimport requestsdef get_iciba(): url = 'http://open.iciba.com/dsapi/' request = requests.get(url) data = json.loads(request) #将json转换为dict return dataprint(get_iciba()) 返回类型：JSON (JSON字段解释：) 属性名 属性值类型 说明 sid string 每日一句id tts string 音频地址 content string 英文\b内容 note string 中文内容 love string 每日一句喜欢个数 translation string 词霸小编 picture string 图片地址 picture2 string 大图片地址 caption string 标题 dateline string 时间 s_pv string 浏览数 sp_pv string 语音评测浏览数 tags string 相关标签 fenxiang_img string 合成图片 正常返回示例1{\"sid\":\"3081\",\"tts\":\"http:\\/\\/news.iciba.com\\/admin\\/tts\\/2018-08-02-day.mp3\",\"content\":\"I am just a sunflower, waiting for my only sunshine.\",\"note\":\"我只是一株向日葵，期待着属于自己的那缕阳光。\",\"love\":\"2154\",\"translation\":\"投稿人的话：地球在转，人生再转，但我们对美好爱情的执着永远不会变。我们就像一株向日葵，期待着属于自己的那缕阳光。\",\"picture\":\"http:\\/\\/cdn.iciba.com\\/news\\/word\\/20180802.jpg\",\"picture2\":\"http:\\/\\/cdn.iciba.com\\/news\\/word\\/big_20180802b.jpg\",\"caption\":\"词霸每日一句\",\"dateline\":\"2018-08-02\",\"s_pv\":\"0\",\"sp_pv\":\"0\",\"tags\":[{\"id\":null,\"name\":null}],\"fenxiang_img\":\"http:\\/\\/cdn.iciba.com\\/web\\/news\\/longweibo\\/imag\\/2018-08-02.jpg\"} 登陆微信公众平台借口测试账号\b\b微信公众号测试申请https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login 扫描后手机端确认登陆 找到“新增测试模板”，添加\b模板消息填写模板标题“每日一句”（可根据需求自己随便填） 提交后，记住改模版的id，一会用到。 找到测试二维码，扫描后，右侧出现你的昵称和微信号，记录下微信号python程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/usr/bin/python#coding=utf-8import jsonimport requestsclass iciba: # 初始化 def __init__(self, wechat_config): self.appid = wechat_config['appid'] self.appsecret = wechat_config['appsecret'] self.template_id = wechat_config['template_id'] self.access_token = '' # 获取access_token def get_access_token(self, appid, appsecret): url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%s&amp;secret=%s' % (appid, appsecret) r = requests.get(url) response = r.content.decode() jdata = json.loads(response) access_token = jdata['access_token'] self.access_token = access_token return self.access_token # 发送消息 def send_msg(self, openid, template_id, iciba_everyday): msg = { 'touser': openid, 'template_id': template_id, 'url': iciba_everyday['fenxiang_img'], 'data': { 'content': { 'value': iciba_everyday['content'], 'color': '#0000CD' }, 'note': { 'value': iciba_everyday['note'], }, 'translation': { 'value': iciba_everyday['translation'], } } } jdata = json.dumps(msg) if self.access_token == '': self.get_access_token(self.appid, self.appsecret) access_token = self.access_token url = 'https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=%s' % str(access_token) request = requests.post(url, data=jdata) #response = urllib.request.urlopen(request) result = request.content.decode() return json.loads(result) # 获取爱词霸每日一句 def get_iciba_everyday(self): url = 'http://open.iciba.com/dsapi/' request = requests.get(url) jdata = request.content.decode() data = json.loads(jdata) return data # 为设置的用户列表发送消息 def send_everyday_words(self, openids): everyday_words = self.get_iciba_everyday() for openid in openids: result = self.send_msg(openid, self.template_id, everyday_words) if result['errcode'] == 0: print(' [INFO] send to %s is success' % openid) else: print(' [ERROR] send to %s is error' % openid) # 执行 def run(self, openids): self.send_everyday_words(openids)if __name__ == '__main__': # 微信配置 wechat_config = { 'appid': 'XXXXX', #此处填写你的appid 'appsecret': 'XXXX', #此处填写你的appsecret 'template_id': 'XXXXX' #此处填写你的模板消息ID } # 用户列表 openids = [ 'XXXXXXX', 'XXXXXXX', #此处填写你的微信号 #'xxxx', #如果有多个用户也可以 #'xxxx', ] # 执行 icb = iciba(wechat_config) icb.run(openids)","link":"/2018/08/03/python2wx/"},{"title":"Raspberry Os","text":"常用树莓派系统","link":"/2018/11/22/raspberry-os/"},{"title":"Static Js Cdn","text":"前段项目日常经常会用到js框架，收集了目前国内主流的cdn服务商提供的静态JS StaticFilestaticfile是一个优秀的开源库并提供CDN服务除了静态的js文件外，staticfile还提供CSS 、图片、和swf等静态文件的CDN服务。 React vue Angular jquery都比较好用。支持http和https两种链接形式。 StaticFile SAE Public Resource渣浪的云服务提供的CDN，界面也比较渣，支持的框架比较少，好在是大牌。SAE CDN CDNJS看名字就知道这个网站是干嘛的。专业的静态js框架cdn服务提供商，提供的JS比较全。CDNJS jsDelivr国外的一家提供前段公共库的网站，只有https服务，界面比较友好。jsDeliver Upyun和Segmentfault又拍云和SegementFault提供的CDN服务。upai","link":"/2018/09/03/static-js-cdn/"},{"title":"播客Feed订阅","text":"🎧 使用 iPhone Safari / Android 系统浏览器，打开本网页，点击下方播客名字，即可添加订阅到播客应用添加到： RSS、 iTunes、 苹果播客、 Overcast、 Castro、 Pocket Casts 看理想《一千零一夜》 看理想《圆桌派》 原来是这样？！ 日谈公园 黑水公园 黑水公园：微信精选推送(微信) 黑水怪谈(微信) 金花漫话(微信) 黑水记(微信) 反派影评 反派影评：耳边风(微信) 反派影评：马后炮(微信) 野史下酒：微信推送 鬼影人间 观复嘟嘟 冬吴同学会 吴晓波频道 诗展侃历史 有话说历史 历史趣谈 大力史 朴素心理学 这事儿我跟你讲 北京话事人 发发大王 齐齐酷咖 糖蒜广播 漫藏道 丁丁说车 王东电台 糗事播报 讨厌在城市读书 游戏时光-VGtime VG聊天室 虎嗅·商业有味道 晓评 读书有疑 静说日本 三联•听周刊 晓说2018 可以谈 婊酱FM 迷失音乐 1UP 播客 友的聊播客 美术史 局座召忠：局座时评(微信) 科学声音龙门阵 36氪·硅谷早知道 第二季 看理想《局部 第一季》 看理想《听说 第一季》","link":"/2018/08/03/podcast/"},{"title":"Science and the Internet","text":"普及一下科学冲浪技巧 普及一下ssr基本原理是在歪果仁哪里租一台服务器，然后在服务器上搭建一个反向代理的服务，歪果仁的服务器访问歪果仁的站点肯定是so爽so快soEasy。 使用方式，打开app然后去找可用的节点，ssr：或者ss：开头的一串乱码》》》 或者是使用软件扫描节点的二维码，直接输入节点信息也可以。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;img src=”https://i.loli.net/2018/08/10/5b6d69daea50a.png&quot; height=”10px” \bwidth=”10px” &gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;win &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mac &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iOS &nbsp;&nbsp;&nbsp;&nbsp;Android windows Mac 联系我下载 Android 请低调传播","link":"/2018/08/07/universets/"},{"title":"Baidu wenku","text":"日常无论是工作还是生活都可能需要用到百毒文库好多都是需要花钱的， 或者你没有下载券，今天分享一个工具，也为自己做个Mark。 工具网址：http://www.1234866.com/ 只能下载 使用下载券下载的文档。","link":"/2018/08/17/wenku/"},{"title":"Windows Collections","text":"##windows 10 license licenseWin10专业版 7M2H3-J3VPB-2X2DK-33CC2-CHPH4 ​Win10 企业版：XCBWP-GN2BX-QJDYV-XQV7K-C7JWR Win10专业版：V942D-C7NFG-773PY-MT398-F3KTY Collection up to spare","link":"/2018/11/22/windows-collections/"}],"tags":[{"name":"ebook,kindle,collect","slug":"ebook-kindle-collect","link":"/tags/ebook-kindle-collect/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"micropython,esp8266,Oled,collect","slug":"micropython-esp8266-Oled-collect","link":"/tags/micropython-esp8266-Oled-collect/"},{"name":"markdown,fontawesome,collect","slug":"markdown-fontawesome-collect","link":"/tags/markdown-fontawesome-collect/"},{"name":"collect","slug":"collect","link":"/tags/collect/"},{"name":"python,wechat,collect","slug":"python-wechat-collect","link":"/tags/python-wechat-collect/"},{"name":"python,raspberry,collect","slug":"python-raspberry-collect","link":"/tags/python-raspberry-collect/"},{"name":"javascript,study,collect","slug":"javascript-study-collect","link":"/tags/javascript-study-collect/"},{"name":"podcast,study,collect","slug":"podcast-study-collect","link":"/tags/podcast-study-collect/"},{"name":"ssr,shadow,collect","slug":"ssr-shadow-collect","link":"/tags/ssr-shadow-collect/"},{"name":"baidu,data,collect","slug":"baidu-data-collect","link":"/tags/baidu-data-collect/"},{"name":"windows,license,collect","slug":"windows-license-collect","link":"/tags/windows-license-collect/"}],"categories":[{"name":"ebook","slug":"ebook","link":"/categories/ebook/"},{"name":"docs","slug":"docs","link":"/categories/docs/"},{"name":"micropython","slug":"micropython","link":"/categories/micropython/"},{"name":"index","slug":"ebook/index","link":"/categories/ebook/index/"},{"name":"markdown","slug":"markdown","link":"/categories/markdown/"},{"name":"index","slug":"docs/index","link":"/categories/docs/index/"},{"name":"python","slug":"docs/python","link":"/categories/docs/python/"},{"name":"raspberry","slug":"docs/raspberry","link":"/categories/docs/raspberry/"},{"name":"javascript","slug":"docs/javascript","link":"/categories/docs/javascript/"},{"name":"podcast","slug":"docs/podcast","link":"/categories/docs/podcast/"},{"name":"index","slug":"micropython/index","link":"/categories/micropython/index/"},{"name":"ssr","slug":"ssr","link":"/categories/ssr/"},{"name":"baidu","slug":"baidu","link":"/categories/baidu/"},{"name":"license","slug":"license","link":"/categories/license/"},{"name":"index","slug":"markdown/index","link":"/categories/markdown/index/"},{"name":"index","slug":"docs/python/index","link":"/categories/docs/python/index/"},{"name":"index","slug":"docs/raspberry/index","link":"/categories/docs/raspberry/index/"},{"name":"index","slug":"docs/javascript/index","link":"/categories/docs/javascript/index/"},{"name":"index","slug":"docs/podcast/index","link":"/categories/docs/podcast/index/"},{"name":"python","slug":"ssr/python","link":"/categories/ssr/python/"},{"name":"index","slug":"baidu/index","link":"/categories/baidu/index/"},{"name":"windows","slug":"license/windows","link":"/categories/license/windows/"},{"name":"index","slug":"ssr/python/index","link":"/categories/ssr/python/index/"},{"name":"index","slug":"license/windows/index","link":"/categories/license/windows/index/"}]}